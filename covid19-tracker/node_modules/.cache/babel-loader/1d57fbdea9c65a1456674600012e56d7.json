{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar invariant_1 = require(\"@turf/invariant\"); // http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\n\n\nfunction booleanPointInPolygon(point, polygon, options) {\n  if (options === void 0) {\n    options = {};\n  } // validation\n\n\n  if (!point) {\n    throw new Error(\"point is required\");\n  }\n\n  if (!polygon) {\n    throw new Error(\"polygon is required\");\n  }\n\n  var pt = invariant_1.getCoord(point);\n  var geom = invariant_1.getGeom(polygon);\n  var type = geom.type;\n  var bbox = polygon.bbox;\n  var polys = geom.coordinates; // Quick elimination if point is not inside bbox\n\n  if (bbox && inBBox(pt, bbox) === false) {\n    return false;\n  } // normalize to multipolygon\n\n\n  if (type === \"Polygon\") {\n    polys = [polys];\n  }\n\n  var insidePoly = false;\n\n  for (var i = 0; i < polys.length && !insidePoly; i++) {\n    // check if it is in the outer ring first\n    if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n      var inHole = false;\n      var k = 1; // check for the point in any of the holes\n\n      while (k < polys[i].length && !inHole) {\n        if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n          inHole = true;\n        }\n\n        k++;\n      }\n\n      if (!inHole) {\n        insidePoly = true;\n      }\n    }\n  }\n\n  return insidePoly;\n}\n\nexports.default = booleanPointInPolygon;\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\n\nfunction inRing(pt, ring, ignoreBoundary) {\n  var isInside = false;\n\n  if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n    ring = ring.slice(0, ring.length - 1);\n  }\n\n  for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n    var xi = ring[i][0];\n    var yi = ring[i][1];\n    var xj = ring[j][0];\n    var yj = ring[j][1];\n    var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;\n\n    if (onBoundary) {\n      return !ignoreBoundary;\n    }\n\n    var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;\n\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n\n  return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\n\n\nfunction inBBox(pt, bbox) {\n  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n}","map":{"version":3,"sources":["/Users/alexacevedo/git/CovidTracker_Cs481/covid19-tracker/node_modules/@turf/boolean-point-in-polygon/index.js"],"names":["Object","defineProperty","exports","value","invariant_1","require","booleanPointInPolygon","point","polygon","options","Error","pt","getCoord","geom","getGeom","type","bbox","polys","coordinates","inBBox","insidePoly","i","length","inRing","ignoreBoundary","inHole","k","default","ring","isInside","slice","j","xi","yi","xj","yj","onBoundary","intersect"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nfunction booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = invariant_1.getCoord(point);\n    var geom = invariant_1.getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\nexports.default = booleanPointInPolygon;\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n            (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n        bbox[1] <= pt[1] &&\n        bbox[2] >= pt[0] &&\n        bbox[3] >= pt[1];\n}\n"]},"metadata":{},"sourceType":"script"}