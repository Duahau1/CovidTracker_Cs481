{"ast":null,"code":"import { Box3, BufferGeometry, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry, Vector2, ShaderLib, ShaderMaterial, UniformsLib, UniformsUtils, Mesh } from 'three';\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\n\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry\n}; // support multiple method names for backwards threejs compatibility\n\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nvar LineSegmentsGeometry = function () {\n  THREE.InstancedBufferGeometry.call(this);\n  this.type = 'LineSegmentsGeometry';\n  var positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n  var uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n  var index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n  this.setIndex(index);\n  this[setAttributeFn]('position', new THREE.Float32BufferAttribute(positions, 3));\n  this[setAttributeFn]('uv', new THREE.Float32BufferAttribute(uvs, 2));\n};\n\nLineSegmentsGeometry.prototype = Object.assign(Object.create(THREE.InstancedBufferGeometry.prototype), {\n  constructor: LineSegmentsGeometry,\n  isLineSegmentsGeometry: true,\n  applyMatrix: function (matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  },\n  applyMatrix4: function (matrix) {\n    var start = this.attributes.instanceStart;\n    var end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      matrix.applyToBufferAttribute(start);\n      matrix.applyToBufferAttribute(end);\n      start.data.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  },\n  setPositions: function (array) {\n    var lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n\n    var instanceBuffer = new THREE.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn]('instanceStart', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn]('instanceEnd', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  },\n  setColors: function (array) {\n    var colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n\n    var instanceColorBuffer = new THREE.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn]('instanceColorStart', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn]('instanceColorEnd', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  },\n  fromWireframeGeometry: function (geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  },\n  fromEdgesGeometry: function (geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  },\n  fromMesh: function (mesh) {\n    this.fromWireframeGeometry(new THREE.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  },\n  fromLineSegements: function (lineSegments) {\n    var geometry = lineSegments.geometry;\n\n    if (geometry.isGeometry) {\n      this.setPositions(geometry.vertices);\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  },\n  computeBoundingBox: function () {\n    var box = new THREE.Box3();\n    return function computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new THREE.Box3();\n      }\n\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n\n      if (start !== undefined && end !== undefined) {\n        this.boundingBox.setFromBufferAttribute(start);\n        box.setFromBufferAttribute(end);\n        this.boundingBox.union(box);\n      }\n    };\n  }(),\n  computeBoundingSphere: function () {\n    var vector = new THREE.Vector3();\n    return function computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new THREE.Sphere();\n      }\n\n      if (this.boundingBox === null) {\n        this.computeBoundingBox();\n      }\n\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n\n      if (start !== undefined && end !== undefined) {\n        var center = this.boundingSphere.center;\n        this.boundingBox.getCenter(center);\n        var maxRadiusSq = 0;\n\n        for (var i = 0, il = start.count; i < il; i++) {\n          vector.fromBufferAttribute(start, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n          vector.fromBufferAttribute(end, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n        }\n\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n        }\n      }\n    };\n  }(),\n  toJSON: function () {// todo\n  },\n  clone: function () {// todo\n  },\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2\n};\nTHREE$1.UniformsLib.line = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  gapSize: {\n    value: 1\n  } // todo FIX - maybe change to totalSize\n\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader: `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader: `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}\n\t\t`\n};\n\nvar LineMaterial = function (parameters) {\n  THREE$1.ShaderMaterial.call(this, {\n    type: 'LineMaterial',\n    uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n    vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n    fragmentShader: THREE$1.ShaderLib['line'].fragmentShader\n  });\n  this.dashed = false;\n  Object.defineProperties(this, {\n    color: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.diffuse.value;\n      },\n      set: function (value) {\n        this.uniforms.diffuse.value = value;\n      }\n    },\n    linewidth: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.linewidth.value;\n      },\n      set: function (value) {\n        this.uniforms.linewidth.value = value;\n      }\n    },\n    dashScale: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.dashScale.value;\n      },\n      set: function (value) {\n        this.uniforms.dashScale.value = value;\n      }\n    },\n    dashSize: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.dashSize.value;\n      },\n      set: function (value) {\n        this.uniforms.dashSize.value = value;\n      }\n    },\n    gapSize: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.gapSize.value;\n      },\n      set: function (value) {\n        this.uniforms.gapSize.value = value;\n      }\n    },\n    resolution: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.resolution.value;\n      },\n      set: function (value) {\n        this.uniforms.resolution.value.copy(value);\n      }\n    }\n  });\n  this.setValues(parameters);\n};\n\nLineMaterial.prototype = Object.create(THREE$1.ShaderMaterial.prototype);\nLineMaterial.prototype.constructor = LineMaterial;\nLineMaterial.prototype.isLineMaterial = true;\n\nLineMaterial.prototype.copy = function (source) {\n  THREE$1.ShaderMaterial.prototype.copy.call(this, source);\n  this.color.copy(source.color);\n  this.linewidth = source.linewidth;\n  this.resolution = source.resolution; // todo\n\n  return this;\n};\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\n\n\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Mesh,\n  Vector3\n};\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nvar LineSegments2 = function (geometry, material) {\n  THREE$2.Mesh.call(this);\n  this.type = 'LineSegments2';\n  this.geometry = geometry !== undefined ? geometry : new LineSegmentsGeometry();\n  this.material = material !== undefined ? material : new LineMaterial({\n    color: Math.random() * 0xffffff\n  });\n};\n\nLineSegments2.prototype = Object.assign(Object.create(THREE$2.Mesh.prototype), {\n  constructor: LineSegments2,\n  isLineSegments2: true,\n  computeLineDistances: function () {\n    // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n    var start = new THREE$2.Vector3();\n    var end = new THREE$2.Vector3();\n    return function computeLineDistances() {\n      var geometry = this.geometry;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n      var lineDistances = new Float32Array(2 * instanceStart.data.count);\n\n      for (var i = 0, j = 0, l = instanceStart.data.count; i < l; i++, j += 2) {\n        start.fromBufferAttribute(instanceStart, i);\n        end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + start.distanceTo(end);\n      }\n\n      var instanceDistanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n      geometry[setAttributeFn$1]('instanceDistanceStart', new THREE$2.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n      geometry[setAttributeFn$1]('instanceDistanceEnd', new THREE$2.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n      return this;\n    };\n  }(),\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\n\nvar LineGeometry = function () {\n  LineSegmentsGeometry.call(this);\n  this.type = 'LineGeometry';\n};\n\nLineGeometry.prototype = Object.assign(Object.create(LineSegmentsGeometry.prototype), {\n  constructor: LineGeometry,\n  isLineGeometry: true,\n  setPositions: function (array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n\n    LineSegmentsGeometry.prototype.setPositions.call(this, points);\n    return this;\n  },\n  setColors: function (array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n\n    LineSegmentsGeometry.prototype.setColors.call(this, colors);\n    return this;\n  },\n  fromLine: function (line) {\n    var geometry = line.geometry;\n\n    if (geometry.isGeometry) {\n      this.setPositions(geometry.vertices);\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  },\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\n\nvar Line2 = function (geometry, material) {\n  LineSegments2.call(this);\n  this.type = 'Line2';\n  this.geometry = geometry !== undefined ? geometry : new LineGeometry();\n  this.material = material !== undefined ? material : new LineMaterial({\n    color: Math.random() * 0xffffff\n  });\n};\n\nLine2.prototype = Object.assign(Object.create(LineSegments2.prototype), {\n  constructor: Line2,\n  isLine2: true,\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\nexport { Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry };","map":{"version":3,"sources":["/Users/alexacevedo/git/CovidTracker_Cs481/covid19-tracker/node_modules/three-fatline/dist/three-fatline.module.js"],"names":["Box3","BufferGeometry","Float32BufferAttribute","InstancedBufferGeometry","InstancedInterleavedBuffer","InterleavedBufferAttribute","Sphere","Vector3","WireframeGeometry","Vector2","ShaderLib","ShaderMaterial","UniformsLib","UniformsUtils","Mesh","THREE","window","setAttributeFn","setAttribute","LineSegmentsGeometry","call","type","positions","uvs","index","setIndex","prototype","Object","assign","create","constructor","isLineSegmentsGeometry","applyMatrix","matrix","console","warn","applyMatrix4","start","attributes","instanceStart","end","instanceEnd","undefined","applyToBufferAttribute","data","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","setColors","colors","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","fromLineSegements","isGeometry","vertices","isBufferGeometry","box","setFromBufferAttribute","union","vector","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","error","toJSON","clone","copy","THREE$1","line","linewidth","value","resolution","dashScale","dashSize","gapSize","uniforms","merge","common","fog","vertexShader","fragmentShader","LineMaterial","parameters","dashed","defineProperties","color","enumerable","get","diffuse","set","setValues","isLineMaterial","source","THREE$2","setAttributeFn$1","LineSegments2","material","random","isLineSegments2","computeLineDistances","lineDistances","j","l","distanceTo","instanceDistanceBuffer","LineGeometry","isLineGeometry","length","points","fromLine","Line2","isLine2"],"mappings":"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","sourcesContent":["import { Box3, BufferGeometry, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry, Vector2, ShaderLib, ShaderMaterial, UniformsLib, UniformsUtils, Mesh } from 'three';\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\nconst THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  Box3,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry\n}; // support multiple method names for backwards threejs compatibility\n\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nvar LineSegmentsGeometry = function () {\n  THREE.InstancedBufferGeometry.call(this);\n  this.type = 'LineSegmentsGeometry';\n  var positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n  var uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n  var index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n  this.setIndex(index);\n  this[setAttributeFn]('position', new THREE.Float32BufferAttribute(positions, 3));\n  this[setAttributeFn]('uv', new THREE.Float32BufferAttribute(uvs, 2));\n};\n\nLineSegmentsGeometry.prototype = Object.assign(Object.create(THREE.InstancedBufferGeometry.prototype), {\n  constructor: LineSegmentsGeometry,\n  isLineSegmentsGeometry: true,\n  applyMatrix: function (matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  },\n  applyMatrix4: function (matrix) {\n    var start = this.attributes.instanceStart;\n    var end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      matrix.applyToBufferAttribute(start);\n      matrix.applyToBufferAttribute(end);\n      start.data.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  },\n  setPositions: function (array) {\n    var lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n\n    var instanceBuffer = new THREE.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this[setAttributeFn]('instanceStart', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this[setAttributeFn]('instanceEnd', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  },\n  setColors: function (array) {\n    var colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n\n    var instanceColorBuffer = new THREE.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this[setAttributeFn]('instanceColorStart', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this[setAttributeFn]('instanceColorEnd', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  },\n  fromWireframeGeometry: function (geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  },\n  fromEdgesGeometry: function (geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  },\n  fromMesh: function (mesh) {\n    this.fromWireframeGeometry(new THREE.WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  },\n  fromLineSegements: function (lineSegments) {\n    var geometry = lineSegments.geometry;\n\n    if (geometry.isGeometry) {\n      this.setPositions(geometry.vertices);\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  },\n  computeBoundingBox: function () {\n    var box = new THREE.Box3();\n    return function computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new THREE.Box3();\n      }\n\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n\n      if (start !== undefined && end !== undefined) {\n        this.boundingBox.setFromBufferAttribute(start);\n        box.setFromBufferAttribute(end);\n        this.boundingBox.union(box);\n      }\n    };\n  }(),\n  computeBoundingSphere: function () {\n    var vector = new THREE.Vector3();\n    return function computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new THREE.Sphere();\n      }\n\n      if (this.boundingBox === null) {\n        this.computeBoundingBox();\n      }\n\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n\n      if (start !== undefined && end !== undefined) {\n        var center = this.boundingSphere.center;\n        this.boundingBox.getCenter(center);\n        var maxRadiusSq = 0;\n\n        for (var i = 0, il = start.count; i < il; i++) {\n          vector.fromBufferAttribute(start, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n          vector.fromBufferAttribute(end, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n        }\n\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n        }\n      }\n    };\n  }(),\n  toJSON: function () {// todo\n  },\n  clone: function () {// todo\n  },\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\nconst THREE$1 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  ShaderLib,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2\n};\nTHREE$1.UniformsLib.line = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  gapSize: {\n    value: 1\n  } // todo FIX - maybe change to totalSize\n\n};\nTHREE$1.ShaderLib['line'] = {\n  uniforms: THREE$1.UniformsUtils.merge([THREE$1.UniformsLib.common, THREE$1.UniformsLib.fog, THREE$1.UniformsLib.line]),\n  vertexShader: `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader: `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}\n\t\t`\n};\n\nvar LineMaterial = function (parameters) {\n  THREE$1.ShaderMaterial.call(this, {\n    type: 'LineMaterial',\n    uniforms: THREE$1.UniformsUtils.clone(THREE$1.ShaderLib['line'].uniforms),\n    vertexShader: THREE$1.ShaderLib['line'].vertexShader,\n    fragmentShader: THREE$1.ShaderLib['line'].fragmentShader\n  });\n  this.dashed = false;\n  Object.defineProperties(this, {\n    color: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.diffuse.value;\n      },\n      set: function (value) {\n        this.uniforms.diffuse.value = value;\n      }\n    },\n    linewidth: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.linewidth.value;\n      },\n      set: function (value) {\n        this.uniforms.linewidth.value = value;\n      }\n    },\n    dashScale: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.dashScale.value;\n      },\n      set: function (value) {\n        this.uniforms.dashScale.value = value;\n      }\n    },\n    dashSize: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.dashSize.value;\n      },\n      set: function (value) {\n        this.uniforms.dashSize.value = value;\n      }\n    },\n    gapSize: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.gapSize.value;\n      },\n      set: function (value) {\n        this.uniforms.gapSize.value = value;\n      }\n    },\n    resolution: {\n      enumerable: true,\n      get: function () {\n        return this.uniforms.resolution.value;\n      },\n      set: function (value) {\n        this.uniforms.resolution.value.copy(value);\n      }\n    }\n  });\n  this.setValues(parameters);\n};\n\nLineMaterial.prototype = Object.create(THREE$1.ShaderMaterial.prototype);\nLineMaterial.prototype.constructor = LineMaterial;\nLineMaterial.prototype.isLineMaterial = true;\n\nLineMaterial.prototype.copy = function (source) {\n  THREE$1.ShaderMaterial.prototype.copy.call(this, source);\n  this.color.copy(source.color);\n  this.linewidth = source.linewidth;\n  this.resolution = source.resolution; // todo\n\n  return this;\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\nconst THREE$2 = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Mesh,\n  Vector3\n};\n\nvar setAttributeFn$1 = new THREE$2.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nvar LineSegments2 = function (geometry, material) {\n  THREE$2.Mesh.call(this);\n  this.type = 'LineSegments2';\n  this.geometry = geometry !== undefined ? geometry : new LineSegmentsGeometry();\n  this.material = material !== undefined ? material : new LineMaterial({\n    color: Math.random() * 0xffffff\n  });\n};\n\nLineSegments2.prototype = Object.assign(Object.create(THREE$2.Mesh.prototype), {\n  constructor: LineSegments2,\n  isLineSegments2: true,\n  computeLineDistances: function () {\n    // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n    var start = new THREE$2.Vector3();\n    var end = new THREE$2.Vector3();\n    return function computeLineDistances() {\n      var geometry = this.geometry;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n      var lineDistances = new Float32Array(2 * instanceStart.data.count);\n\n      for (var i = 0, j = 0, l = instanceStart.data.count; i < l; i++, j += 2) {\n        start.fromBufferAttribute(instanceStart, i);\n        end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + start.distanceTo(end);\n      }\n\n      var instanceDistanceBuffer = new THREE$2.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n      geometry[setAttributeFn$1]('instanceDistanceStart', new THREE$2.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n      geometry[setAttributeFn$1]('instanceDistanceEnd', new THREE$2.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n      return this;\n    };\n  }(),\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\n\nvar LineGeometry = function () {\n  LineSegmentsGeometry.call(this);\n  this.type = 'LineGeometry';\n};\n\nLineGeometry.prototype = Object.assign(Object.create(LineSegmentsGeometry.prototype), {\n  constructor: LineGeometry,\n  isLineGeometry: true,\n  setPositions: function (array) {\n    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n    var length = array.length - 3;\n    var points = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      points[2 * i] = array[i];\n      points[2 * i + 1] = array[i + 1];\n      points[2 * i + 2] = array[i + 2];\n      points[2 * i + 3] = array[i + 3];\n      points[2 * i + 4] = array[i + 4];\n      points[2 * i + 5] = array[i + 5];\n    }\n\n    LineSegmentsGeometry.prototype.setPositions.call(this, points);\n    return this;\n  },\n  setColors: function (array) {\n    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n    var length = array.length - 3;\n    var colors = new Float32Array(2 * length);\n\n    for (var i = 0; i < length; i += 3) {\n      colors[2 * i] = array[i];\n      colors[2 * i + 1] = array[i + 1];\n      colors[2 * i + 2] = array[i + 2];\n      colors[2 * i + 3] = array[i + 3];\n      colors[2 * i + 4] = array[i + 4];\n      colors[2 * i + 5] = array[i + 5];\n    }\n\n    LineSegmentsGeometry.prototype.setColors.call(this, colors);\n    return this;\n  },\n  fromLine: function (line) {\n    var geometry = line.geometry;\n\n    if (geometry.isGeometry) {\n      this.setPositions(geometry.vertices);\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  },\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n */\n\nvar Line2 = function (geometry, material) {\n  LineSegments2.call(this);\n  this.type = 'Line2';\n  this.geometry = geometry !== undefined ? geometry : new LineGeometry();\n  this.material = material !== undefined ? material : new LineMaterial({\n    color: Math.random() * 0xffffff\n  });\n};\n\nLine2.prototype = Object.assign(Object.create(LineSegments2.prototype), {\n  constructor: Line2,\n  isLine2: true,\n  copy: function ()\n  /* source */\n  {\n    // todo\n    return this;\n  }\n});\n\nexport { Line2, LineGeometry, LineMaterial, LineSegments2, LineSegmentsGeometry };\n"]},"metadata":{},"sourceType":"module"}