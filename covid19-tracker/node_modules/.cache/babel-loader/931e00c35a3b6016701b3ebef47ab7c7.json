{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute, Geometry } from 'three';\nimport earcut from 'earcut';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nvar getInterpolatedVals = function getInterpolatedVals(start, end, numPnts) {\n  var result = [];\n\n  for (var i = 1; i <= numPnts; i++) {\n    result.push(start + (end - start) * i / (numPnts + 1));\n  }\n\n  return result;\n};\n\nvar interpolateLine = function interpolateLine() {\n  var lineCoords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var maxDegDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var result = [];\n  var prevPnt = null;\n  lineCoords.forEach(function (pnt) {\n    if (prevPnt) {\n      var dist = Math.sqrt(Math.pow(pnt[0] - prevPnt[0], 2) + Math.pow(pnt[1] - prevPnt[1], 2));\n\n      if (dist > maxDegDistance) {\n        var numAdditionalPnts = Math.floor(dist / maxDegDistance);\n        var lngs = getInterpolatedVals(prevPnt[0], pnt[0], numAdditionalPnts);\n        var lats = getInterpolatedVals(prevPnt[1], pnt[1], numAdditionalPnts);\n\n        for (var i = 0, len = lngs.length; i < len; i++) {\n          result.push([lngs[i], lats[i]]);\n        }\n      }\n    }\n\n    result.push(prevPnt = pnt);\n  });\n  return result;\n};\n\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute,\n  Geometry: Geometry\n};\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nfunction GeoJsonGeometry(geoJson) {\n  var _this = this;\n\n  var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var resolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n  THREE.BufferGeometry.call(this);\n  this.type = 'GeoJsonGeometry';\n  this.parameters = {\n    geoJson: geoJson,\n    radius: radius,\n    resolution: resolution\n  }; // process various geometry types\n\n  var groups = ({\n    Point: genPoint,\n    MultiPoint: genMultiPoint,\n    LineString: genLineString,\n    MultiLineString: genMultiLineString,\n    Polygon: genPolygon,\n    MultiPolygon: genMultiPolygon\n  }[geoJson.type] || function () {\n    return [];\n  })(geoJson.coordinates, radius); // concat groups\n\n\n  var indices = [],\n      vertices = [];\n  var groupCnt = 0;\n  groups.forEach(function (newG) {\n    var prevIndCnt = indices.length;\n    concatGroup({\n      indices: indices,\n      vertices: vertices\n    }, newG);\n\n    _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n  }); // build geometry\n\n  indices.length && this.setIndex(indices);\n  vertices.length && this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3)); //\n\n  function genPoint(coords, r) {\n    var vertices = polar2Cartesian(coords[1], coords[0], r);\n    var indices = [];\n    return [{\n      vertices: vertices,\n      indices: indices\n    }];\n  }\n\n  function genMultiPoint(coords, r) {\n    var result = {\n      vertices: [],\n      indices: []\n    };\n    coords.map(function (c) {\n      return genPoint(c, r);\n    }).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          newPnt = _ref2[0];\n\n      concatGroup(result, newPnt);\n    });\n    return [result];\n  }\n\n  function genLineString(coords, r) {\n    var coords3d = interpolateLine(coords, resolution).map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          lng = _ref4[0],\n          lat = _ref4[1];\n\n      return polar2Cartesian(lat, lng, r);\n    });\n\n    var _earcut$flatten = earcut.flatten([coords3d]),\n        vertices = _earcut$flatten.vertices;\n\n    var numPoints = Math.round(vertices.length / 3);\n    var indices = [];\n\n    for (var vIdx = 1; vIdx < numPoints; vIdx++) {\n      indices.push(vIdx - 1, vIdx);\n    }\n\n    return [{\n      vertices: vertices,\n      indices: indices\n    }];\n  }\n\n  function genMultiLineString(coords, r) {\n    var result = {\n      vertices: [],\n      indices: []\n    };\n    coords.map(function (c) {\n      return genLineString(c, r);\n    }).forEach(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 1),\n          newLine = _ref6[0];\n\n      concatGroup(result, newLine);\n    });\n    return [result];\n  }\n\n  function genPolygon(coords, r) {\n    var coords3d = coords.map(function (coordsSegment) {\n      return interpolateLine(coordsSegment, resolution).map(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            lng = _ref8[0],\n            lat = _ref8[1];\n\n        return polar2Cartesian(lat, lng, r);\n      });\n    }); // Each point generates 3 vertice items (x,y,z).\n\n    var _earcut$flatten2 = earcut.flatten(coords3d),\n        vertices = _earcut$flatten2.vertices,\n        holes = _earcut$flatten2.holes;\n\n    var firstHoleIdx = holes[0] || Infinity;\n    var outerVertices = vertices.slice(0, firstHoleIdx);\n    var holeVertices = vertices.slice(firstHoleIdx);\n    var holesIdx = new Set(holes);\n    var numPoints = Math.round(vertices.length / 3);\n    var outerIndices = [],\n        holeIndices = [];\n\n    for (var vIdx = 1; vIdx < numPoints; vIdx++) {\n      if (!holesIdx.has(vIdx)) {\n        if (vIdx < firstHoleIdx) {\n          outerIndices.push(vIdx - 1, vIdx);\n        } else {\n          holeIndices.push(vIdx - 1 - firstHoleIdx, vIdx - firstHoleIdx);\n        }\n      }\n    }\n\n    var groups = [{\n      indices: outerIndices,\n      vertices: outerVertices\n    }];\n\n    if (holes.length) {\n      groups.push({\n        indices: holeIndices,\n        vertices: holeVertices\n      });\n    }\n\n    return groups;\n  }\n\n  function genMultiPolygon(coords, r) {\n    var outer = {\n      vertices: [],\n      indices: []\n    };\n    var holes = {\n      vertices: [],\n      indices: []\n    };\n    coords.map(function (c) {\n      return genPolygon(c, r);\n    }).forEach(function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 2),\n          newOuter = _ref10[0],\n          newHoles = _ref10[1];\n\n      concatGroup(outer, newOuter);\n      newHoles && concatGroup(holes, newHoles);\n    });\n    var groups = [outer];\n    holes.vertices.length && groups.push(holes);\n    return groups;\n  }\n}\n\nGeoJsonGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nGeoJsonGeometry.prototype.constructor = GeoJsonGeometry; //\n\nfunction concatGroup(main, extra) {\n  var prevVertCnt = Math.round(main.vertices.length / 3);\n  concatArr(main.vertices, extra.vertices);\n  concatArr(main.indices, extra.indices.map(function (ind) {\n    return ind + prevVertCnt;\n  }));\n}\n\nfunction concatArr(target, src) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = src[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var e = _step.value;\n      target.push(e);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta), // x\n  r * Math.cos(phi), // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\nexport { GeoJsonGeometry };","map":{"version":3,"sources":["/Users/alexacevedo/git/CovidTracker_Cs481/covid19-tracker/node_modules/three-geojson-geometry/dist/three-geojson-geometry.module.js"],"names":["BufferGeometry","Float32BufferAttribute","Geometry","earcut","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","Array","isArray","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","TypeError","getInterpolatedVals","start","end","numPnts","result","interpolateLine","lineCoords","arguments","maxDegDistance","prevPnt","forEach","pnt","dist","Math","sqrt","pow","numAdditionalPnts","floor","lngs","lats","len","THREE","window","setAttributeFn","setAttribute","GeoJsonGeometry","geoJson","_this","radius","resolution","type","parameters","groups","Point","genPoint","MultiPoint","genMultiPoint","LineString","genLineString","MultiLineString","genMultiLineString","Polygon","genPolygon","MultiPolygon","genMultiPolygon","coordinates","indices","vertices","groupCnt","newG","prevIndCnt","concatGroup","addGroup","setIndex","coords","r","polar2Cartesian","map","c","_ref","_ref2","newPnt","coords3d","_ref3","_ref4","lng","lat","_earcut$flatten","flatten","numPoints","round","vIdx","_ref5","_ref6","newLine","coordsSegment","_ref7","_ref8","_earcut$flatten2","holes","firstHoleIdx","Infinity","outerVertices","slice","holeVertices","holesIdx","Set","outerIndices","holeIndices","has","outer","_ref9","_ref10","newOuter","newHoles","create","constructor","main","extra","prevVertCnt","concatArr","ind","target","src","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","e","phi","PI","theta","sin","cos"],"mappings":"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","sourcesContent":["import { BufferGeometry, Float32BufferAttribute, Geometry } from 'three';\nimport earcut from 'earcut';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nvar getInterpolatedVals = function getInterpolatedVals(start, end, numPnts) {\n  var result = [];\n\n  for (var i = 1; i <= numPnts; i++) {\n    result.push(start + (end - start) * i / (numPnts + 1));\n  }\n\n  return result;\n};\n\nvar interpolateLine = function interpolateLine() {\n  var lineCoords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var maxDegDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var result = [];\n  var prevPnt = null;\n  lineCoords.forEach(function (pnt) {\n    if (prevPnt) {\n      var dist = Math.sqrt(Math.pow(pnt[0] - prevPnt[0], 2) + Math.pow(pnt[1] - prevPnt[1], 2));\n\n      if (dist > maxDegDistance) {\n        var numAdditionalPnts = Math.floor(dist / maxDegDistance);\n        var lngs = getInterpolatedVals(prevPnt[0], pnt[0], numAdditionalPnts);\n        var lats = getInterpolatedVals(prevPnt[1], pnt[1], numAdditionalPnts);\n\n        for (var i = 0, len = lngs.length; i < len; i++) {\n          result.push([lngs[i], lats[i]]);\n        }\n      }\n    }\n\n    result.push(prevPnt = pnt);\n  });\n  return result;\n};\n\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute,\n  Geometry: Geometry\n};\n\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nfunction GeoJsonGeometry(geoJson) {\n  var _this = this;\n\n  var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var resolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n  THREE.BufferGeometry.call(this);\n  this.type = 'GeoJsonGeometry';\n  this.parameters = {\n    geoJson: geoJson,\n    radius: radius,\n    resolution: resolution\n  }; // process various geometry types\n\n  var groups = ({\n    Point: genPoint,\n    MultiPoint: genMultiPoint,\n    LineString: genLineString,\n    MultiLineString: genMultiLineString,\n    Polygon: genPolygon,\n    MultiPolygon: genMultiPolygon\n  }[geoJson.type] || function () {\n    return [];\n  })(geoJson.coordinates, radius); // concat groups\n\n\n  var indices = [],\n      vertices = [];\n  var groupCnt = 0;\n  groups.forEach(function (newG) {\n    var prevIndCnt = indices.length;\n    concatGroup({\n      indices: indices,\n      vertices: vertices\n    }, newG);\n\n    _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n  }); // build geometry\n\n  indices.length && this.setIndex(indices);\n  vertices.length && this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3)); //\n\n  function genPoint(coords, r) {\n    var vertices = polar2Cartesian(coords[1], coords[0], r);\n    var indices = [];\n    return [{\n      vertices: vertices,\n      indices: indices\n    }];\n  }\n\n  function genMultiPoint(coords, r) {\n    var result = {\n      vertices: [],\n      indices: []\n    };\n    coords.map(function (c) {\n      return genPoint(c, r);\n    }).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          newPnt = _ref2[0];\n\n      concatGroup(result, newPnt);\n    });\n    return [result];\n  }\n\n  function genLineString(coords, r) {\n    var coords3d = interpolateLine(coords, resolution).map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          lng = _ref4[0],\n          lat = _ref4[1];\n\n      return polar2Cartesian(lat, lng, r);\n    });\n\n    var _earcut$flatten = earcut.flatten([coords3d]),\n        vertices = _earcut$flatten.vertices;\n\n    var numPoints = Math.round(vertices.length / 3);\n    var indices = [];\n\n    for (var vIdx = 1; vIdx < numPoints; vIdx++) {\n      indices.push(vIdx - 1, vIdx);\n    }\n\n    return [{\n      vertices: vertices,\n      indices: indices\n    }];\n  }\n\n  function genMultiLineString(coords, r) {\n    var result = {\n      vertices: [],\n      indices: []\n    };\n    coords.map(function (c) {\n      return genLineString(c, r);\n    }).forEach(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 1),\n          newLine = _ref6[0];\n\n      concatGroup(result, newLine);\n    });\n    return [result];\n  }\n\n  function genPolygon(coords, r) {\n    var coords3d = coords.map(function (coordsSegment) {\n      return interpolateLine(coordsSegment, resolution).map(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            lng = _ref8[0],\n            lat = _ref8[1];\n\n        return polar2Cartesian(lat, lng, r);\n      });\n    }); // Each point generates 3 vertice items (x,y,z).\n\n    var _earcut$flatten2 = earcut.flatten(coords3d),\n        vertices = _earcut$flatten2.vertices,\n        holes = _earcut$flatten2.holes;\n\n    var firstHoleIdx = holes[0] || Infinity;\n    var outerVertices = vertices.slice(0, firstHoleIdx);\n    var holeVertices = vertices.slice(firstHoleIdx);\n    var holesIdx = new Set(holes);\n    var numPoints = Math.round(vertices.length / 3);\n    var outerIndices = [],\n        holeIndices = [];\n\n    for (var vIdx = 1; vIdx < numPoints; vIdx++) {\n      if (!holesIdx.has(vIdx)) {\n        if (vIdx < firstHoleIdx) {\n          outerIndices.push(vIdx - 1, vIdx);\n        } else {\n          holeIndices.push(vIdx - 1 - firstHoleIdx, vIdx - firstHoleIdx);\n        }\n      }\n    }\n\n    var groups = [{\n      indices: outerIndices,\n      vertices: outerVertices\n    }];\n\n    if (holes.length) {\n      groups.push({\n        indices: holeIndices,\n        vertices: holeVertices\n      });\n    }\n\n    return groups;\n  }\n\n  function genMultiPolygon(coords, r) {\n    var outer = {\n      vertices: [],\n      indices: []\n    };\n    var holes = {\n      vertices: [],\n      indices: []\n    };\n    coords.map(function (c) {\n      return genPolygon(c, r);\n    }).forEach(function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 2),\n          newOuter = _ref10[0],\n          newHoles = _ref10[1];\n\n      concatGroup(outer, newOuter);\n      newHoles && concatGroup(holes, newHoles);\n    });\n    var groups = [outer];\n    holes.vertices.length && groups.push(holes);\n    return groups;\n  }\n}\n\nGeoJsonGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nGeoJsonGeometry.prototype.constructor = GeoJsonGeometry; //\n\nfunction concatGroup(main, extra) {\n  var prevVertCnt = Math.round(main.vertices.length / 3);\n  concatArr(main.vertices, extra.vertices);\n  concatArr(main.indices, extra.indices.map(function (ind) {\n    return ind + prevVertCnt;\n  }));\n}\n\nfunction concatArr(target, src) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = src[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var e = _step.value;\n      target.push(e);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta), // x\n  r * Math.cos(phi), // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\nexport { GeoJsonGeometry };\n"]},"metadata":{},"sourceType":"module"}