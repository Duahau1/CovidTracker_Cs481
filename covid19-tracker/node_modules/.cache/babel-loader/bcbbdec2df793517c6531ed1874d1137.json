{"ast":null,"code":"import { ShaderMaterial as e, Color as r, Face3 as o, BackSide as n, Mesh as i } from \"three\";\nvar t = {\n  backside: !0,\n  coefficient: .5,\n  color: \"gold\",\n  size: 2,\n  power: 1\n};\n\nfunction a(o, n, i) {\n  return new e({\n    depthWrite: !1,\n    fragmentShader: \"\\nuniform vec3 color;\\nuniform float coefficient;\\nuniform float power;\\nvarying vec3 vVertexNormal;\\nvarying vec3 vVertexWorldPosition;\\nvoid main() {\\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\\n  vec3 viewCameraToVertex\\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\\n  viewCameraToVertex = normalize(viewCameraToVertex);\\n  float intensity\\t= pow(\\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\\n    power\\n  );\\n  gl_FragColor = vec4(color, intensity);\\n}\",\n    transparent: !0,\n    uniforms: {\n      coefficient: {\n        value: o\n      },\n      color: {\n        value: new r(n)\n      },\n      power: {\n        value: i\n      }\n    },\n    vertexShader: \"\\nvarying vec3 vVertexWorldPosition;\\nvarying vec3 vVertexNormal;\\nvoid main() {\\n  vVertexNormal\\t= normalize(normalMatrix * normal);\\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\\n  gl_Position\\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\"\n  });\n}\n\nfunction c(e, r) {\n  var n = e.clone(),\n      i = new Array(n.vertices.length);\n  return n.faces.forEach(function (e) {\n    e instanceof o ? (i[e.a] = e.vertexNormals[0], i[e.b] = e.vertexNormals[1], i[e.c] = e.vertexNormals[2]) : console.error(\"Face needs to be an instance of THREE.Face3.\");\n  }), n.vertices.forEach(function (e, o) {\n    var n = i[o],\n        t = n.y,\n        a = n.z;\n    e.x += n.x * r, e.y += t * r, e.z += a * r;\n  }), n;\n}\n\nfunction v(e, r) {\n  void 0 === r && (r = t);\n  var o = r.backside,\n      v = r.coefficient,\n      l = r.color,\n      f = r.power,\n      m = c(e, r.size),\n      x = a(v, l, f);\n  return o && (x.side = n), new i(m, x);\n}\n\nexport { c as createGlowGeometry, a as createGlowMaterial, v as createGlowMesh, t as defaultOptions };","map":{"version":3,"sources":["../index.js"],"names":["defaultOptions","backside","coefficient","color","size","power","createGlowMaterial","ShaderMaterial","depthWrite","fragmentShader","transparent","uniforms","value","Color","vertexShader","createGlowGeometry","geometry","glowGeometry","clone","vertexNormals","Array","vertices","length","faces","forEach","face","Face3","a","b","c","console","error","vertex","i","x","y","z","createGlowMesh","options","glowMaterial","side","BackSide","Mesh"],"mappings":";AAEA,IA2BaA,CAAAA,GAAiB;AAC5BC,EAAAA,QAAAA,EAAAA,CAAU,CADkB;AAE5BC,EAAAA,WAAAA,EAAa,EAFe;AAG5BC,EAAAA,KAAAA,EAAO,MAHqB;AAI5BC,EAAAA,IAAAA,EAAM,CAJsB;AAK5BC,EAAAA,KAAAA,EAAO;AALqB,CA3B9B;;AAgCS,SAIOC,CAJP,CAI0BJ,CAJ1B,EAIuCC,CAJvC,EAI8CE,CAJ9C,EAI8CA;AACrD,SAAA,IAAWE,CAAX,CAA0B;AACxBC,IAAAA,UAAAA,EAAAA,CAAY,CADY;AAExBC,IAAAA,cAAAA,EAAAA,0fAFwB;AAGxBC,IAAAA,WAAAA,EAAAA,CAAa,CAHW;AAIxBC,IAAAA,QAAAA,EAAU;AACRT,MAAAA,WAAAA,EAAa;AACXU,QAAAA,KAAAA,EAAOV;AADI,OADL;AAIRC,MAAAA,KAAAA,EAAO;AACLS,QAAAA,KAAAA,EAAO,IAAIC,CAAJ,CAAUV,CAAV;AADF,OAJC;AAORE,MAAAA,KAAAA,EAAO;AACLO,QAAAA,KAAAA,EAAOP;AADF;AAPC,KAJc;AAexBS,IAAAA,YAAAA,EAAAA;AAfwB,GAA1B,CAAA;AAeEA;;AAAAA,SAIYC,CAJZD,CAI+BE,CAJ/BF,EAIyCV,CAJzCU,EAIyCV;AAE3C,MAAMa,CAAAA,GAAeD,CAAAA,CAASE,KAATF,EAArB;AAAA,MACMG,CAAAA,GAAgB,IAAIC,KAAJ,CAAUH,CAAAA,CAAaI,QAAbJ,CAAsBK,MAAhC,CADtB;AAoBA,SAlBAL,CAAAA,CAAaM,KAAbN,CAAmBO,OAAnBP,CAA2B,UAACQ,CAAD,EAACA;AACtBA,IAAAA,CAAAA,YAAgBC,CAAhBD,IACFN,CAAAA,CAAcM,CAAAA,CAAKE,CAAnBR,CAAAA,GAAwBM,CAAAA,CAAKN,aAALM,CAAmB,CAAnBA,CAAxBN,EACAA,CAAAA,CAAcM,CAAAA,CAAKG,CAAnBT,CAAAA,GAAwBM,CAAAA,CAAKN,aAALM,CAAmB,CAAnBA,CADxBN,EAEAA,CAAAA,CAAcM,CAAAA,CAAKI,CAAnBV,CAAAA,GAAwBM,CAAAA,CAAKN,aAALM,CAAmB,CAAnBA,CAHtBA,IAKFK,OAAAA,CAAQC,KAARD,CAAc,8CAAdA,CALEL;AAKY,GANlBR,GAWAA,CAAAA,CAAaI,QAAbJ,CAAsBO,OAAtBP,CAA8B,UAACe,CAAD,EAASC,CAAT,EAASA;AAAAA,QAAAA,CAAAA,GACjBd,CAAAA,CAAcc,CAAdd,CADiBc;AAAAA,QAC1BE,CAAAA,GAAAA,CAAAA,CAAAA,CAD0BF;AAAAA,QACvBG,CAAAA,GAAAA,CAAAA,CAAAA,CADuBH;AAErCD,IAAAA,CAAAA,CAAOE,CAAPF,IAAOE,CAAAA,CADCA,CACDA,GAAS9B,CAAhB4B,EACAA,CAAAA,CAAOG,CAAPH,IAAYG,CAAAA,GAAI/B,CADhB4B,EAEAA,CAAAA,CAAOI,CAAPJ,IAAYI,CAAAA,GAAIhC,CAFhB4B;AAEgB5B,GAJlBa,CAXAA,EAkBOA,CAAP;AAAOA;;AAAAA,SAGOoB,CAHPpB,CAGsBD,CAHtBC,EAGgCqB,CAHhCrB,EAGgCqB;AAAAA,OAAAA,CAAAA,KAAAA,CAAAA,KAAAA,CAAAA,GAAUtC,CAAVsC;AAAUtC,MACzCC,CAAAA,GAA8CqC,CAAAA,CAA9CrC,QADyCD;AAAAA,MAC/BE,CAAAA,GAAoCoC,CAAAA,CAApCpC,WAD+BF;AAAAA,MAClBG,CAAAA,GAAuBmC,CAAAA,CAAvBnC,KADkBH;AAAAA,MACLK,CAAAA,GAAUiC,CAAAA,CAAVjC,KADKL;AAAAA,MAG3CiB,CAAAA,GAAeF,CAAAA,CAAmBC,CAAnBD,EAFiCuB,CAAAA,CAAhBlC,IAEjBW,CAH4Bf;AAAAA,MAI3CuC,CAAAA,GAAejC,CAAAA,CAAmBJ,CAAnBI,EAAgCH,CAAhCG,EAAuCD,CAAvCC,CAJ4BN;AAUjD,SAJIC,CAAAA,KACFsC,CAAAA,CAAaC,IAAbD,GAAoBE,CADlBxC,CAAAA,EACkBwC,IAGXC,CAHWD,CAGNxB,CAHMwB,EAGQF,CAHRE,CAGtB;AAA8BF;;AAAAA,SAAAA,CAAAA,IAAAA,kBAAAA,EAAAA,CAAAA,IAAAA,kBAAAA,EAAAA,CAAAA,IAAAA,cAAAA,EAAAA,CAAAA,IAAAA,cAAAA","sourcesContent":["import { BackSide, Color, Face3, Mesh, ShaderMaterial } from 'three';\n\nconst fragmentShader = `\nuniform vec3 color;\nuniform float coefficient;\nuniform float power;\nvarying vec3 vVertexNormal;\nvarying vec3 vVertexWorldPosition;\nvoid main() {\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\n  vec3 viewCameraToVertex\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\n  viewCameraToVertex = normalize(viewCameraToVertex);\n  float intensity\t= pow(\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\n    power\n  );\n  gl_FragColor = vec4(color, intensity);\n}`;\n\nconst vertexShader = `\nvarying vec3 vVertexWorldPosition;\nvarying vec3 vVertexNormal;\nvoid main() {\n  vVertexNormal\t= normalize(normalMatrix * normal);\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  gl_Position\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nexport const defaultOptions = {\n  backside: true,\n  coefficient: 0.5,\n  color: 'gold',\n  size: 2,\n  power: 1,\n};\n\n// Based off: http://stemkoski.blogspot.fr/2013/07/shaders-in-threejs-glow-and-halo.html\nexport function createGlowMaterial(coefficient, color, power) {\n  return new ShaderMaterial({\n    depthWrite: false,\n    fragmentShader,\n    transparent: true,\n    uniforms: {\n      coefficient: {\n        value: coefficient,\n      },\n      color: {\n        value: new Color(color),\n      },\n      power: {\n        value: power,\n      },\n    },\n    vertexShader,\n  });\n}\n\nexport function createGlowGeometry(geometry, size) {\n  // Gather vertexNormals from geometry.faces\n  const glowGeometry = geometry.clone();\n  const vertexNormals = new Array(glowGeometry.vertices.length);\n  glowGeometry.faces.forEach((face) => {\n    if (face instanceof Face3) {\n      vertexNormals[face.a] = face.vertexNormals[0];\n      vertexNormals[face.b] = face.vertexNormals[1];\n      vertexNormals[face.c] = face.vertexNormals[2];\n    } else {\n      console.error('Face needs to be an instance of THREE.Face3.');\n    }\n  });\n\n  // Modify the vertices according to vertexNormal\n  glowGeometry.vertices.forEach((vertex, i) => {\n    const { x, y, z } = vertexNormals[i];\n    vertex.x += x * size;\n    vertex.y += y * size;\n    vertex.z += z * size;\n  });\n\n  return glowGeometry;\n}\n\nexport function createGlowMesh(geometry, options = defaultOptions) {\n  const { backside, coefficient, color, size, power } = options;\n\n  const glowGeometry = createGlowGeometry(geometry, size);\n  const glowMaterial = createGlowMaterial(coefficient, color, power);\n\n  if (backside) {\n    glowMaterial.side = BackSide;\n  }\n\n  return new Mesh(glowGeometry, glowMaterial);\n}\n"]},"metadata":{},"sourceType":"module"}