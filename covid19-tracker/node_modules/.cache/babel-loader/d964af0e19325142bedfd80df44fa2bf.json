{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute, Geometry } from 'three';\nimport Delaunator from 'delaunator';\nimport earcut from 'earcut';\nimport turfPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { geoDistance, geoInterpolate } from 'd3-geo';\nimport { merge, extent, mean } from 'd3-array';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute,\n  Geometry: Geometry\n};\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nfunction ConicPolygonGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n  THREE.Geometry.call(this);\n  this.type = 'ConicPolygonGeometry';\n  this.parameters = {\n    polygonGeoJson: polygonGeoJson,\n    startHeight: startHeight,\n    endHeight: endHeight,\n    closedBottom: closedBottom,\n    closedTop: closedTop,\n    includeSides: includeSides,\n    curvatureResolution: curvatureResolution\n  };\n  this.fromBufferGeometry(new ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution));\n  this.mergeVertices();\n}\n\nConicPolygonGeometry.prototype = Object.create(THREE.Geometry.prototype);\nConicPolygonGeometry.prototype.constructor = ConicPolygonGeometry;\n\nfunction ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n  var _this = this;\n\n  THREE.BufferGeometry.call(this);\n  this.type = 'ConicPolygonBufferGeometry';\n  this.parameters = {\n    polygonGeoJson: polygonGeoJson,\n    startHeight: startHeight,\n    endHeight: endHeight,\n    closedBottom: closedBottom,\n    closedTop: closedTop,\n    includeSides: includeSides,\n    curvatureResolution: curvatureResolution\n  }; // defaults\n\n  startHeight = startHeight || 0;\n  endHeight = endHeight || 1;\n  closedBottom = closedBottom !== undefined ? closedBottom : true;\n  closedTop = closedTop !== undefined ? closedTop : true;\n  includeSides = includeSides !== undefined ? includeSides : true;\n  curvatureResolution = curvatureResolution || 5; // in angular degrees\n  // pre-calculate contour and triangulation\n\n  var contourGeoJson = interpolateContourPoints(polygonGeoJson, curvatureResolution);\n  var geoTriangles = (closedTop || closedBottom) && triangulateGeoSurface();\n  var vertices = [];\n  var indices = [];\n  var groupCnt = 0; // add groups to apply different materials to torso / caps\n\n  var addGroup = function addGroup(groupData) {\n    var prevVertCnt = Math.round(vertices.length / 3);\n    var prevIndCnt = indices.length;\n    vertices = vertices.concat(groupData.vertices);\n    indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {\n      return ind + prevVertCnt;\n    }));\n\n    _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n  };\n\n  includeSides && addGroup(generateTorso());\n  closedBottom && addGroup(generateCap(startHeight, false));\n  closedTop && addGroup(generateCap(endHeight, true)); // build geometry\n\n  this.setIndex(indices);\n  this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3)); // auto-calculate normals\n\n  this.computeFaceNormals();\n  this.computeVertexNormals(); //\n\n  function generateVertices(polygon, altitude) {\n    var coords3d = polygon.map(function (coords) {\n      return coords.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            lng = _ref2[0],\n            lat = _ref2[1];\n\n        return polar2Cartesian(lat, lng, altitude);\n      });\n    }); // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n\n    return earcut.flatten(coords3d);\n  }\n\n  function generateTorso() {\n    var _generateVertices = generateVertices(contourGeoJson, startHeight),\n        bottomVerts = _generateVertices.vertices,\n        holes = _generateVertices.holes;\n\n    var _generateVertices2 = generateVertices(contourGeoJson, endHeight),\n        topVerts = _generateVertices2.vertices;\n\n    var vertices = merge([topVerts, bottomVerts]);\n    var numPoints = Math.round(topVerts.length / 3);\n    var holesIdx = new Set(holes);\n    var lastHoleIdx = 0;\n    var indices = [];\n\n    for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {\n      var v1Idx = v0Idx + 1; // next point\n\n      if (v1Idx === numPoints) {\n        v1Idx = lastHoleIdx; // close final loop\n      } else if (holesIdx.has(v1Idx)) {\n        var holeIdx = v1Idx;\n        v1Idx = lastHoleIdx; // close hole loop\n\n        lastHoleIdx = holeIdx;\n      } // Each pair of coords generates two triangles (faces)\n\n\n      indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n      indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n    }\n\n    return {\n      indices: indices,\n      vertices: vertices\n    };\n  }\n\n  function generateCap(radius) {\n    var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return {\n      // need to reverse-wind the bottom triangles to make them face outwards\n      indices: isTop ? geoTriangles.indices : geoTriangles.indices.slice().reverse(),\n      vertices: generateVertices([geoTriangles.points], radius).vertices\n    };\n  }\n\n  function triangulateGeoSurface() {\n    var edgePnts = merge(contourGeoJson);\n    var innerPoints = getInnerGeoPoints(polygonGeoJson, curvatureResolution);\n    var points = [].concat(_toConsumableArray(edgePnts), _toConsumableArray(innerPoints));\n    var indices = [];\n\n    if (!innerPoints.length) {\n      // earcut triangulation slightly more performant if it's only using the polygon perimeter\n      var _earcut$flatten = earcut.flatten(contourGeoJson),\n          _vertices = _earcut$flatten.vertices,\n          _earcut$flatten$holes = _earcut$flatten.holes,\n          holes = _earcut$flatten$holes === void 0 ? [] : _earcut$flatten$holes;\n\n      indices = earcut(_vertices, holes, 2);\n    } else {\n      (function () {\n        var delaunay = Delaunator.from(points);\n        var boundariesGeojson = {\n          type: 'Polygon',\n          coordinates: polygonGeoJson\n        };\n\n        var _loop = function _loop(i, len) {\n          var _indices;\n\n          var inds = [2, 1, 0].map(function (idx) {\n            return delaunay.triangles[i + idx];\n          }); // reverse wound to have same orientation as earcut\n\n          var triangle = inds.map(function (indice) {\n            return points[indice];\n          }); // exclude edge triangles outside polygon perimeter or through holes\n\n          if (inds.some(function (ind) {\n            return ind < edgePnts.length;\n          })) {\n            var triangleCentroid = [0, 1].map(function (coordIdx) {\n              return mean(triangle, function (p) {\n                return p[coordIdx];\n              });\n            });\n            if (!pointInside(triangleCentroid, boundariesGeojson)) return \"continue\";\n          }\n\n          (_indices = indices).push.apply(_indices, _toConsumableArray(inds));\n        };\n\n        for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {\n          var _ret = _loop(i);\n\n          if (_ret === \"continue\") continue;\n        }\n      })();\n    }\n\n    return {\n      points: points,\n      indices: indices\n    };\n  }\n}\n\nConicPolygonBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nConicPolygonBufferGeometry.prototype.constructor = ConicPolygonBufferGeometry; //\n\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta), // x\n  r * Math.cos(phi), // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\nfunction pointInside(pnt, polygonGeoJson) {\n  return turfPointInPolygon(pnt, polygonGeoJson);\n}\n\nfunction interpolateContourPoints(polygonGeoJson, maxDistance) {\n  // add interpolated points for segments that are further apart than the max distance\n  return polygonGeoJson.map(function (coords) {\n    var pnts = [];\n    var prevPnt;\n    coords.forEach(function (pnt) {\n      if (prevPnt) {\n        var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;\n\n        if (dist > maxDistance) {\n          var interpol = geoInterpolate(prevPnt, pnt);\n          var tStep = 1 / Math.ceil(dist / maxDistance);\n          var t = tStep;\n\n          while (t < 1) {\n            pnts.push(interpol(t));\n            t += tStep;\n          }\n        }\n      }\n\n      pnts.push(prevPnt = pnt);\n    });\n    return pnts;\n  });\n}\n\nfunction getInnerGeoPoints(polygonGeoJson, maxDistance) {\n  var _extent = extent(polygonGeoJson[0], function (p) {\n    return p[0];\n  }),\n      _extent2 = _slicedToArray(_extent, 2),\n      minLng = _extent2[0],\n      maxLng = _extent2[1];\n\n  var _extent3 = extent(polygonGeoJson[0], function (p) {\n    return p[1];\n  }),\n      _extent4 = _slicedToArray(_extent3, 2),\n      minLat = _extent4[0],\n      maxLat = _extent4[1]; // polygon smaller than maxDistance -> no inner points\n\n\n  if (Math.min(maxLng - minLng, maxLat - minLat) < maxDistance) return []; // distribute grid remainder equally on both sides\n\n  var startLng = minLng + (maxLng - minLng) % maxDistance / 2;\n  var startLat = minLat + (maxLat - minLat) % maxDistance / 2;\n  var pnts = [];\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygonGeoJson\n  }; // iterate through grid\n\n  var lng = startLng;\n  var lat;\n\n  while (lng < maxLng) {\n    lat = startLat;\n\n    while (lat < maxLat) {\n      var pnt = [lng, lat];\n      pointInside(pnt, boundariesGeojson) && pnts.push(pnt);\n      lat += maxDistance;\n    }\n\n    lng += maxDistance;\n  }\n\n  return pnts;\n}\n\nexport { ConicPolygonBufferGeometry, ConicPolygonGeometry };","map":{"version":3,"sources":["/Users/alexacevedo/git/CovidTracker_Cs481/covid19-tracker/node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.module.js"],"names":["BufferGeometry","Float32BufferAttribute","Geometry","Delaunator","earcut","turfPointInPolygon","geoDistance","geoInterpolate","merge","extent","mean","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","Symbol","iterator","Object","from","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","o","minLen","n","prototype","toString","call","slice","constructor","name","test","len","arr2","TypeError","THREE","window","setAttributeFn","setAttribute","ConicPolygonGeometry","polygonGeoJson","startHeight","endHeight","closedBottom","closedTop","includeSides","curvatureResolution","type","parameters","fromBufferGeometry","ConicPolygonBufferGeometry","mergeVertices","create","_this","contourGeoJson","interpolateContourPoints","geoTriangles","triangulateGeoSurface","vertices","indices","groupCnt","addGroup","groupData","prevVertCnt","Math","round","prevIndCnt","concat","map","ind","generateTorso","generateCap","setIndex","computeFaceNormals","computeVertexNormals","generateVertices","polygon","altitude","coords3d","coords","_ref","_ref2","lng","lat","polar2Cartesian","flatten","_generateVertices","bottomVerts","holes","_generateVertices2","topVerts","numPoints","holesIdx","Set","lastHoleIdx","v0Idx","v1Idx","has","holeIdx","radius","isTop","arguments","reverse","points","edgePnts","innerPoints","getInnerGeoPoints","_earcut$flatten","_vertices","_earcut$flatten$holes","delaunay","boundariesGeojson","coordinates","_loop","_indices","inds","idx","triangles","triangle","indice","some","triangleCentroid","coordIdx","p","pointInside","apply","_ret","r","phi","PI","theta","sin","cos","pnt","maxDistance","pnts","prevPnt","forEach","dist","interpol","tStep","ceil","t","_extent","_extent2","minLng","maxLng","_extent3","_extent4","minLat","maxLat","min","startLng","startLat"],"mappings":"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","sourcesContent":["import { BufferGeometry, Float32BufferAttribute, Geometry } from 'three';\nimport Delaunator from 'delaunator';\nimport earcut from 'earcut';\nimport turfPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { geoDistance, geoInterpolate } from 'd3-geo';\nimport { merge, extent, mean } from 'd3-array';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute,\n  Geometry: Geometry\n};\n\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\n\nfunction ConicPolygonGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n  THREE.Geometry.call(this);\n  this.type = 'ConicPolygonGeometry';\n  this.parameters = {\n    polygonGeoJson: polygonGeoJson,\n    startHeight: startHeight,\n    endHeight: endHeight,\n    closedBottom: closedBottom,\n    closedTop: closedTop,\n    includeSides: includeSides,\n    curvatureResolution: curvatureResolution\n  };\n  this.fromBufferGeometry(new ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution));\n  this.mergeVertices();\n}\n\nConicPolygonGeometry.prototype = Object.create(THREE.Geometry.prototype);\nConicPolygonGeometry.prototype.constructor = ConicPolygonGeometry;\n\nfunction ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n  var _this = this;\n\n  THREE.BufferGeometry.call(this);\n  this.type = 'ConicPolygonBufferGeometry';\n  this.parameters = {\n    polygonGeoJson: polygonGeoJson,\n    startHeight: startHeight,\n    endHeight: endHeight,\n    closedBottom: closedBottom,\n    closedTop: closedTop,\n    includeSides: includeSides,\n    curvatureResolution: curvatureResolution\n  }; // defaults\n\n  startHeight = startHeight || 0;\n  endHeight = endHeight || 1;\n  closedBottom = closedBottom !== undefined ? closedBottom : true;\n  closedTop = closedTop !== undefined ? closedTop : true;\n  includeSides = includeSides !== undefined ? includeSides : true;\n  curvatureResolution = curvatureResolution || 5; // in angular degrees\n  // pre-calculate contour and triangulation\n\n  var contourGeoJson = interpolateContourPoints(polygonGeoJson, curvatureResolution);\n  var geoTriangles = (closedTop || closedBottom) && triangulateGeoSurface();\n  var vertices = [];\n  var indices = [];\n  var groupCnt = 0; // add groups to apply different materials to torso / caps\n\n  var addGroup = function addGroup(groupData) {\n    var prevVertCnt = Math.round(vertices.length / 3);\n    var prevIndCnt = indices.length;\n    vertices = vertices.concat(groupData.vertices);\n    indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {\n      return ind + prevVertCnt;\n    }));\n\n    _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n  };\n\n  includeSides && addGroup(generateTorso());\n  closedBottom && addGroup(generateCap(startHeight, false));\n  closedTop && addGroup(generateCap(endHeight, true)); // build geometry\n\n  this.setIndex(indices);\n  this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3)); // auto-calculate normals\n\n  this.computeFaceNormals();\n  this.computeVertexNormals(); //\n\n  function generateVertices(polygon, altitude) {\n    var coords3d = polygon.map(function (coords) {\n      return coords.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            lng = _ref2[0],\n            lat = _ref2[1];\n\n        return polar2Cartesian(lat, lng, altitude);\n      });\n    }); // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n\n    return earcut.flatten(coords3d);\n  }\n\n  function generateTorso() {\n    var _generateVertices = generateVertices(contourGeoJson, startHeight),\n        bottomVerts = _generateVertices.vertices,\n        holes = _generateVertices.holes;\n\n    var _generateVertices2 = generateVertices(contourGeoJson, endHeight),\n        topVerts = _generateVertices2.vertices;\n\n    var vertices = merge([topVerts, bottomVerts]);\n    var numPoints = Math.round(topVerts.length / 3);\n    var holesIdx = new Set(holes);\n    var lastHoleIdx = 0;\n    var indices = [];\n\n    for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {\n      var v1Idx = v0Idx + 1; // next point\n\n      if (v1Idx === numPoints) {\n        v1Idx = lastHoleIdx; // close final loop\n      } else if (holesIdx.has(v1Idx)) {\n        var holeIdx = v1Idx;\n        v1Idx = lastHoleIdx; // close hole loop\n\n        lastHoleIdx = holeIdx;\n      } // Each pair of coords generates two triangles (faces)\n\n\n      indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n      indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n    }\n\n    return {\n      indices: indices,\n      vertices: vertices\n    };\n  }\n\n  function generateCap(radius) {\n    var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return {\n      // need to reverse-wind the bottom triangles to make them face outwards\n      indices: isTop ? geoTriangles.indices : geoTriangles.indices.slice().reverse(),\n      vertices: generateVertices([geoTriangles.points], radius).vertices\n    };\n  }\n\n  function triangulateGeoSurface() {\n    var edgePnts = merge(contourGeoJson);\n    var innerPoints = getInnerGeoPoints(polygonGeoJson, curvatureResolution);\n    var points = [].concat(_toConsumableArray(edgePnts), _toConsumableArray(innerPoints));\n    var indices = [];\n\n    if (!innerPoints.length) {\n      // earcut triangulation slightly more performant if it's only using the polygon perimeter\n      var _earcut$flatten = earcut.flatten(contourGeoJson),\n          _vertices = _earcut$flatten.vertices,\n          _earcut$flatten$holes = _earcut$flatten.holes,\n          holes = _earcut$flatten$holes === void 0 ? [] : _earcut$flatten$holes;\n\n      indices = earcut(_vertices, holes, 2);\n    } else {\n      (function () {\n        var delaunay = Delaunator.from(points);\n        var boundariesGeojson = {\n          type: 'Polygon',\n          coordinates: polygonGeoJson\n        };\n\n        var _loop = function _loop(i, len) {\n          var _indices;\n\n          var inds = [2, 1, 0].map(function (idx) {\n            return delaunay.triangles[i + idx];\n          }); // reverse wound to have same orientation as earcut\n\n          var triangle = inds.map(function (indice) {\n            return points[indice];\n          }); // exclude edge triangles outside polygon perimeter or through holes\n\n          if (inds.some(function (ind) {\n            return ind < edgePnts.length;\n          })) {\n            var triangleCentroid = [0, 1].map(function (coordIdx) {\n              return mean(triangle, function (p) {\n                return p[coordIdx];\n              });\n            });\n            if (!pointInside(triangleCentroid, boundariesGeojson)) return \"continue\";\n          }\n\n          (_indices = indices).push.apply(_indices, _toConsumableArray(inds));\n        };\n\n        for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {\n          var _ret = _loop(i);\n\n          if (_ret === \"continue\") continue;\n        }\n      })();\n    }\n\n    return {\n      points: points,\n      indices: indices\n    };\n  }\n}\n\nConicPolygonBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\nConicPolygonBufferGeometry.prototype.constructor = ConicPolygonBufferGeometry; //\n\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta), // x\n  r * Math.cos(phi), // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\nfunction pointInside(pnt, polygonGeoJson) {\n  return turfPointInPolygon(pnt, polygonGeoJson);\n}\n\nfunction interpolateContourPoints(polygonGeoJson, maxDistance) {\n  // add interpolated points for segments that are further apart than the max distance\n  return polygonGeoJson.map(function (coords) {\n    var pnts = [];\n    var prevPnt;\n    coords.forEach(function (pnt) {\n      if (prevPnt) {\n        var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;\n\n        if (dist > maxDistance) {\n          var interpol = geoInterpolate(prevPnt, pnt);\n          var tStep = 1 / Math.ceil(dist / maxDistance);\n          var t = tStep;\n\n          while (t < 1) {\n            pnts.push(interpol(t));\n            t += tStep;\n          }\n        }\n      }\n\n      pnts.push(prevPnt = pnt);\n    });\n    return pnts;\n  });\n}\n\nfunction getInnerGeoPoints(polygonGeoJson, maxDistance) {\n  var _extent = extent(polygonGeoJson[0], function (p) {\n    return p[0];\n  }),\n      _extent2 = _slicedToArray(_extent, 2),\n      minLng = _extent2[0],\n      maxLng = _extent2[1];\n\n  var _extent3 = extent(polygonGeoJson[0], function (p) {\n    return p[1];\n  }),\n      _extent4 = _slicedToArray(_extent3, 2),\n      minLat = _extent4[0],\n      maxLat = _extent4[1]; // polygon smaller than maxDistance -> no inner points\n\n\n  if (Math.min(maxLng - minLng, maxLat - minLat) < maxDistance) return []; // distribute grid remainder equally on both sides\n\n  var startLng = minLng + (maxLng - minLng) % maxDistance / 2;\n  var startLat = minLat + (maxLat - minLat) % maxDistance / 2;\n  var pnts = [];\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygonGeoJson\n  }; // iterate through grid\n\n  var lng = startLng;\n  var lat;\n\n  while (lng < maxLng) {\n    lat = startLat;\n\n    while (lat < maxLat) {\n      var pnt = [lng, lat];\n      pointInside(pnt, boundariesGeojson) && pnts.push(pnt);\n      lat += maxDistance;\n    }\n\n    lng += maxDistance;\n  }\n\n  return pnts;\n}\n\nexport { ConicPolygonBufferGeometry, ConicPolygonGeometry };\n"]},"metadata":{},"sourceType":"module"}