{"version":3,"file":"index.modern.js","sources":["../lib/defaults.js","../lib/enums.js","../lib/utils.js","../lib/tooltip.js","../lib/globe.js","../lib/renderer.js","../lib/camera.js","../lib/earth.js","../lib/lights.js","../lib/markers.js","../lib/orbit-controls.js","../lib/scene.js","../lib/focus.js","../lib/component.js"],"sourcesContent":["import { BACKGROUND_RADIUS_SCALE, MarkerTypes } from './enums';\n\nexport const defaultCallbacks = {\n  onClickMarker: (_marker, _markerObject, _event) => {},\n  onDefocus: _previousFocus => {},\n  onGlobeBackgroundTextureLoaded: () => {},\n  onGlobeCloudsTextureLoaded: () => {},\n  onGlobeTextureLoaded: () => {},\n  onMouseOutMarker: (_marker, _markerObject, _event) => {},\n  onMouseOverMarker: (_marker, _markerObject, _event) => {},\n};\n\nexport const defaultGlobeBackgroundTexture =\n  'https://raw.githubusercontent.com/chrisrzhou/react-globe/main/textures/background.png';\n\nexport const defaultGlobeCloudsTexture =\n  'https://raw.githubusercontent.com/chrisrzhou/react-globe/main/textures/clouds.png';\n\nexport const defaultGlobeTexture =\n  'https://raw.githubusercontent.com/chrisrzhou/react-globe/main/textures/globe.jpg';\n\nexport const defaultInitialCoordinates = [1.29027, 103.851959]; // singapore!\n\nexport const defaultOptions = {\n  ambientLightColor: 'white',\n  ambientLightIntensity: 0.8,\n  cameraAutoRotateSpeed: 0.1,\n  cameraDistanceRadiusScale: 3,\n  cameraMaxDistanceRadiusScale: BACKGROUND_RADIUS_SCALE,\n  cameraMaxPolarAngle: Math.PI,\n  cameraMinPolarAngle: 0,\n  cameraRotateSpeed: 0.2,\n  cameraZoomSpeed: 1,\n  enableCameraAutoRotate: true,\n  enableCameraRotate: true,\n  enableCameraZoom: true,\n  enableDefocus: true,\n  enableGlobeGlow: true,\n  enableMarkerGlow: true,\n  enableMarkerTooltip: true,\n  focusAnimationDuration: 1000,\n  focusDistanceRadiusScale: 1.5,\n  focusEasingFunction: ['Cubic', 'Out'],\n  globeCloudsOpacity: 0.3,\n  globeGlowCoefficient: 0.1,\n  globeGlowColor: '#d1d1d1',\n  globeGlowPower: 3,\n  globeGlowRadiusScale: 0.2,\n  markerEnterAnimationDuration: 1000,\n  markerEnterEasingFunction: ['Linear', 'None'],\n  markerExitAnimationDuration: 500,\n  markerExitEasingFunction: ['Cubic', 'Out'],\n  markerGlowCoefficient: 0,\n  markerGlowPower: 3,\n  markerGlowRadiusScale: 2,\n  markerOffsetRadiusScale: 0,\n  markerRadiusScaleRange: [0.005, 0.02],\n  markerRenderer: null,\n  markerTooltipRenderer: marker => JSON.stringify(marker.coordinates),\n  markerType: MarkerTypes.DOT,\n  pointLightColor: 'white',\n  pointLightIntensity: 1,\n  pointLightPositionRadiusScales: [-2, 1, -1],\n};\n\nexport const defaultDotMarkerOptions = {\n  enableMarkerGlow: true,\n  markerRadiusScaleRange: [0.005, 0.02],\n  markerType: 'dot',\n};\n\nexport const defaultBarMarkerOptions = {\n  enableMarkerGlow: false,\n  markerRadiusScaleRange: [0.2, 0.5],\n  markerType: 'bar',\n};\n","export const CAMERA_FAR_RADIUS_SCALE = 1000;\nexport const BACKGROUND_RADIUS_SCALE = CAMERA_FAR_RADIUS_SCALE / 10;\nexport const RADIUS = 300;\n\nexport const MarkerTypes = {\n  BAR: 'bar',\n  DOT: 'dot',\n};\n","import * as TWEEN from 'es6-tween';\nimport ResizeObserver from 'resize-observer-polyfill';\n\nexport function coordinatesToPosition(coordinates, radius) {\n  const [lat, long] = coordinates;\n  const phi = (lat * Math.PI) / 180;\n  const theta = ((long - 180) * Math.PI) / 180;\n\n  const x = -radius * Math.cos(phi) * Math.cos(theta);\n  const y = radius * Math.sin(phi);\n  const z = radius * Math.cos(phi) * Math.sin(theta);\n\n  return [x, y, z];\n}\n\nexport function merge(object, defaultObject) {\n  const merged = { ...defaultObject };\n  Object.keys(merged).forEach(key => {\n    const value = object[key];\n    merged[key] = value === undefined ? merged[key] : value;\n  });\n  return merged;\n}\n\nexport function resize(element, callback) {\n  const resizeObserver = new ResizeObserver(entries => {\n    if (!entries || entries.length === 0) {\n      return;\n    }\n    const { height, width } = entries[0].contentRect;\n    callback({ height, width });\n  });\n\n  resizeObserver.observe(element);\n\n  return () => resizeObserver.unobserve(element);\n}\n\nexport function tween({\n  from,\n  to,\n  animationDuration,\n  easingFunction,\n  onUpdate,\n  onEnd = null,\n  delay = 0,\n}) {\n  const [equation, type] = easingFunction;\n\n  new TWEEN.Tween(from)\n    .to(to, animationDuration)\n    .easing(TWEEN.Easing[equation][type])\n    .on('update', onUpdate)\n    .on('complete', onEnd)\n    .delay(delay)\n    .start();\n}\n","import tippy from 'tippy.js';\n\nconst TOOLTIP_OFFSET = 10;\n\nexport default class Tooltip {\n  constructor(element) {\n    this.element = element;\n    this.instance = tippy([element], {\n      animation: 'scale',\n      arrow: false,\n    })[0];\n  }\n\n  destroy() {\n    this.instance.destroy();\n  }\n\n  hide() {\n    document.body.style.cursor = 'inherit';\n    this.element.style.position = 'fixed';\n    this.element.style.left = '0';\n    this.element.style.top = '0';\n    this.instance.hide();\n  }\n\n  show(clientX, clientY, content) {\n    document.body.style.cursor = 'pointer';\n    this.element.style.position = 'fixed';\n    this.element.style.left = `${clientX + TOOLTIP_OFFSET}px`;\n    this.element.style.top = `${clientY + TOOLTIP_OFFSET}px`;\n    this.instance.setContent(content);\n    this.instance.show();\n  }\n}\n","import * as TWEEN from 'es6-tween';\n\nimport { createCamera } from './camera';\nimport {\n  defaultCallbacks,\n  defaultInitialCoordinates,\n  defaultOptions,\n} from './defaults';\nimport { createEarth, updateEarth } from './earth';\nimport { updateFocus } from './focus';\nimport { createLights, updateLights } from './lights';\nimport { createMarkerObjects, updateMarkerObjects } from './markers';\nimport { createOrbitControls, updateOrbitControls } from './orbit-controls';\nimport { createRenderer } from './renderer';\nimport { createScene } from './scene';\nimport Tooltip from './tooltip';\nimport { merge } from './utils';\n\nexport default class Globe {\n  constructor({\n    canvasElement,\n    initialCameraDistanceRadiusScale = defaultOptions.cameraDistanceRadiusScale,\n    initialCoordinates = defaultInitialCoordinates,\n    textures = {},\n    tooltipElement,\n  }) {\n    // state variables\n    this.callbacks = defaultCallbacks;\n    this.focus = null;\n    this.isLocked = false;\n    this.markers = [];\n    this.options = defaultOptions;\n    this.textures = textures;\n    this.previousFocus = null;\n    this.tooltip = new Tooltip(tooltipElement);\n\n    // create objects\n    this.renderer = createRenderer(canvasElement);\n    this.camera = createCamera(\n      initialCoordinates,\n      initialCameraDistanceRadiusScale,\n    );\n    this.earth = createEarth();\n    this.lights = createLights();\n    this.markerObjects = createMarkerObjects();\n    this.orbitControls = createOrbitControls(this.camera, this.renderer);\n\n    // assemble scene\n    this.scene = createScene({\n      camera: this.camera,\n      earth: this.earth,\n      lights: this.lights,\n      markerObjects: this.markerObjects,\n      renderer: this.renderer,\n      defocus: this.defocus.bind(this),\n    });\n\n    // initialize\n    this.updateOptions();\n    this.updateCallbacks();\n    this.updateMarkers();\n  }\n\n  animate() {\n    this.render();\n    this.animationFrameId = requestAnimationFrame(this.animate.bind(this));\n  }\n\n  // TODO: make this configurable\n  animateClouds() {\n    ['x', 'y', 'z'].forEach(axis => {\n      this.earth.clouds.rotation[axis] += Math.random() / 10000;\n    });\n  }\n\n  applyAnimations(animations) {\n    // const currentFocus = this.focus;\n    // const currentFocusOptions = this.options.focus;\n    let wait = 0;\n    const timeouts = [];\n    animations.forEach((animation, i) => {\n      const {\n        coordinates,\n        focusAnimationDuration,\n        focusDistanceRadiusScale,\n        focusEasingFunction,\n      } = animation;\n      const overrideOptions = {\n        focusAnimationDuration,\n        focusDistanceRadiusScale,\n        focusEasingFunction,\n      };\n      const shouldUnlockAfterFocus = i === animations.length - 1;\n\n      const timeout = setTimeout(() => {\n        this.unlock();\n        this.updateFocus(coordinates, overrideOptions, shouldUnlockAfterFocus);\n      }, wait);\n      timeouts.push(timeout);\n      wait += focusAnimationDuration;\n    });\n\n    return () => {\n      timeouts.forEach(timeout => {\n        clearTimeout(timeout);\n      });\n    };\n  }\n\n  defocus() {\n    if (!this.isLocked && this.previousFocus && this.options.enableDefocus) {\n      this.updateFocus(null);\n      this.callbacks.onDefocus(this.previousFocus);\n    }\n  }\n\n  destroy() {\n    cancelAnimationFrame(this.animationFrameId);\n    this.tooltip.destroy();\n    this.renderer.domElement.remove();\n  }\n\n  lock() {\n    this.isLocked = true;\n    this.orbitControls.enabled = false;\n    this.orbitControls.autoRotate = false;\n  }\n\n  render() {\n    this.renderer.sortObjects = false;\n    this.renderer.render(this.scene, this.camera);\n    this.orbitControls.update();\n    this.animateClouds();\n    TWEEN.update();\n  }\n\n  resize(size) {\n    const { height, width } = size;\n    this.renderer.setSize(width, height);\n    this.camera.aspect = width / height;\n    this.camera.updateProjectionMatrix();\n    this.render();\n  }\n\n  saveFocus(focusPosition) {\n    this.previousFocus = focusPosition;\n  }\n\n  unlock() {\n    this.isLocked = false;\n    this.orbitControls.enabled = true;\n    this.orbitControls.autoRotate = true;\n  }\n\n  updateCallbacks(callbacks = {}) {\n    this.callbacks = merge(callbacks, defaultCallbacks);\n  }\n\n  updateFocus(focus, overrideOptions = {}, shouldUnlockAfterFocus = true) {\n    if (!this.isLocked) {\n      this.focus = focus;\n      updateFocus(this.focus, this.camera, {\n        shouldUnlockAfterFocus,\n        options: merge(overrideOptions, this.options),\n        previousFocus: this.previousFocus,\n        lock: this.lock.bind(this),\n        unlock: this.unlock.bind(this),\n        saveFocus: this.saveFocus.bind(this),\n      });\n    }\n  }\n\n  updateMarkers(markers = []) {\n    this.markers = markers;\n    const callbacks = {\n      onClickMarker: (marker, markerObject, event) => {\n        this.updateFocus(marker.coordinates);\n        this.callbacks.onClickMarker(marker, markerObject, event);\n      },\n      onMouseOutMarker: (marker, markerObject, event) => {\n        this.tooltip.hide();\n        this.callbacks.onMouseOutMarker(marker, markerObject, event);\n      },\n      onMouseOverMarker: (marker, markerObject, event) => {\n        if (this.options.enableMarkerTooltip) {\n          this.tooltip.show(\n            event.clientX,\n            event.clientY,\n            this.options.markerTooltipRenderer(markerObject.marker),\n          );\n        }\n        this.callbacks.onMouseOverMarker(marker, markerObject, event);\n      },\n    };\n    updateMarkerObjects(this.markerObjects, {\n      options: this.options,\n      markers,\n      callbacks,\n    });\n  }\n\n  updateOptions(options = {}) {\n    this.options = merge(options, defaultOptions);\n    updateEarth(this.earth, {\n      callbacks: this.callbacks,\n      options: this.options,\n      textures: this.textures,\n    });\n    updateLights(this.lights, this.options);\n    updateOrbitControls(this.orbitControls, this.options);\n    this.updateFocus.bind(this, this.focus);\n    this.updateMarkers.bind(this, this.markers);\n  }\n}\n","import { WebGLRenderer } from 'three';\n\nexport function createRenderer(canvas) {\n  return new WebGLRenderer({\n    alpha: true,\n    antialias: true,\n    canvas,\n  });\n}\n","import { PerspectiveCamera } from 'three';\n\nimport { CAMERA_FAR_RADIUS_SCALE, RADIUS } from './enums';\nimport { coordinatesToPosition } from './utils';\n\nconst CAMERA_FAR = RADIUS * CAMERA_FAR_RADIUS_SCALE;\nconst CAMERA_FOV = 45;\nconst CAMERA_NEAR = 1;\n\nexport function createCamera(\n  initialCoordinates,\n  initialCameraDistanceRadiusScale,\n) {\n  const camera = new PerspectiveCamera();\n\n  camera.name = 'camera';\n  camera.far = CAMERA_FAR;\n  camera.fov = CAMERA_FOV;\n  camera.near = CAMERA_NEAR;\n\n  const [x, y, z] = coordinatesToPosition(\n    initialCoordinates,\n    RADIUS * initialCameraDistanceRadiusScale,\n  );\n  camera.position.set(x, y, z);\n\n  return camera;\n}\n","import {\n  BackSide,\n  Mesh,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  SphereGeometry,\n  TextureLoader,\n} from 'three';\nimport { createGlowMesh } from 'three-glow-mesh';\n\nimport {\n  defaultGlobeBackgroundTexture,\n  defaultGlobeCloudsTexture,\n  defaultGlobeTexture,\n} from './defaults';\nimport { BACKGROUND_RADIUS_SCALE, RADIUS } from './enums';\n\nconst CLOUDS_RADIUS_OFFSET = 1;\nconst GLOBE_SEGMENTS = 50;\n\nexport function createEarth() {\n  const globe = new Mesh();\n  globe.geometry = new SphereGeometry(RADIUS, GLOBE_SEGMENTS, GLOBE_SEGMENTS);\n  globe.name = 'earth';\n\n  const clouds = new Mesh();\n  clouds.geometry = new SphereGeometry(\n    RADIUS + CLOUDS_RADIUS_OFFSET,\n    GLOBE_SEGMENTS,\n    GLOBE_SEGMENTS,\n  );\n  clouds.name = 'clouds';\n\n  const background = new Mesh();\n  background.name = 'background';\n  background.geometry = new SphereGeometry(\n    RADIUS * BACKGROUND_RADIUS_SCALE,\n    GLOBE_SEGMENTS,\n    GLOBE_SEGMENTS,\n  );\n\n  return {\n    clouds,\n    globe,\n    background,\n  };\n}\n\nexport function updateEarth(earth, { callbacks, options, textures }) {\n  const {\n    enableGlobeGlow,\n    globeCloudsOpacity,\n    globeGlowColor,\n    globeGlowCoefficient,\n    globeGlowPower,\n    globeGlowRadiusScale,\n  } = options;\n  const {\n    onGlobeBackgroundTextureLoaded,\n    onGlobeCloudsTextureLoaded,\n    onGlobeTextureLoaded,\n  } = callbacks;\n  const {\n    globeBackgroundTexture = defaultGlobeBackgroundTexture,\n    globeCloudsTexture = defaultGlobeCloudsTexture,\n    globeTexture = defaultGlobeTexture,\n  } = textures;\n  let { clouds, globe, glow, background } = earth;\n\n  if (enableGlobeGlow) {\n    glow = createGlowMesh(globe.geometry, {\n      backside: true,\n      coefficient: globeGlowCoefficient,\n      color: globeGlowColor,\n      power: globeGlowPower,\n      size: RADIUS * globeGlowRadiusScale,\n    });\n    glow.name = 'glow';\n  }\n\n  if (globeTexture) {\n    new TextureLoader().load(\n      globeTexture,\n      map => {\n        globe.material = new MeshLambertMaterial({ map });\n        globe.remove(globe.getObjectByName('glow'));\n        globe.add(glow);\n        onGlobeTextureLoaded();\n      },\n      () => {},\n      onGlobeTextureLoaded,\n    );\n  }\n\n  if (globeBackgroundTexture) {\n    new TextureLoader().load(\n      globeBackgroundTexture,\n      map => {\n        background.material = new MeshBasicMaterial({ map, side: BackSide });\n        onGlobeBackgroundTextureLoaded();\n      },\n      () => {},\n      onGlobeBackgroundTextureLoaded,\n    );\n    globe.remove(globe.getObjectByName('background'));\n    globe.add(background);\n  }\n\n  if (globeCloudsTexture) {\n    new TextureLoader().load(\n      globeCloudsTexture,\n      map => {\n        clouds.material = new MeshLambertMaterial({ map, transparent: true });\n        clouds.material.opacity = globeCloudsOpacity;\n        onGlobeCloudsTextureLoaded();\n      },\n      () => {},\n      onGlobeCloudsTextureLoaded,\n    );\n    globe.remove(globe.getObjectByName('clouds'));\n    globe.add(clouds);\n  }\n}\n","import { AmbientLight, Color, PointLight } from 'three';\n\nimport { RADIUS } from './enums';\n\nexport function createLights() {\n  const ambient = new AmbientLight('white');\n  const point = new PointLight('white');\n\n  ambient.name = 'ambientLight';\n  point.name = 'pointLight';\n\n  return {\n    ambient,\n    point,\n  };\n}\n\nexport function updateLights(lights, options) {\n  const {\n    ambientLightColor,\n    ambientLightIntensity,\n    pointLightColor,\n    pointLightIntensity,\n    pointLightPositionRadiusScales,\n  } = options;\n  const { ambient, point } = lights;\n  const [scaleX, scaleY, scaleZ] = pointLightPositionRadiusScales;\n\n  ambient.color = new Color(ambientLightColor);\n  ambient.intensity = ambientLightIntensity;\n\n  point.color = new Color(pointLightColor);\n  point.intensity = pointLightIntensity;\n  point.position.set(RADIUS * scaleX, RADIUS * scaleY, RADIUS * scaleZ);\n}\n","import { scaleLinear } from 'd3-scale';\nimport {\n  BoxGeometry,\n  Group,\n  Mesh,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  SphereGeometry,\n  Vector3,\n} from 'three';\nimport { createGlowMesh } from 'three-glow-mesh';\n\nimport { RADIUS, MarkerTypes } from './enums';\nimport { coordinatesToPosition, tween } from './utils';\n\nconst MARKER_DEFAULT_COLOR = 'gold';\nconst MARKER_SEGMENTS = 10;\nconst MARKER_UNIT_RADIUS_SCALE = 0.01;\n\nexport function createMarkerObjects() {\n  const markerObjects = new Group();\n  markerObjects.name = 'markers';\n\n  return markerObjects;\n}\n\nexport function updateMarkerObjects(\n  markerObjects,\n  { callbacks, markers, options },\n) {\n  const {\n    markerExitAnimationDuration,\n    markerExitEasingFunction,\n    markerRadiusScaleRange,\n  } = options;\n\n  const markerValues = markers.map(marker => marker.value);\n  const markerIdSet = new Set(markers.map(marker => marker.id));\n  const [radiusScaleMin, radiusScaleMax] = markerRadiusScaleRange;\n\n  const sizeScale = scaleLinear()\n    .domain([\n      Math.min.apply(null, markerValues),\n      Math.max.apply(null, markerValues),\n    ])\n    .range([RADIUS * radiusScaleMin, RADIUS * radiusScaleMax]);\n\n  markers.forEach(marker => {\n    const { id, value } = marker;\n    const size = sizeScale(value);\n\n    // create new marker objects if non-existent\n    let markerObject = markerObjects.children.find(\n      object => object.marker.id === marker.id,\n    );\n    if (!markerObject) {\n      markerObject = createMarkerObject(marker, options, size);\n      markerObject.name = id;\n      markerObjects.add(markerObject);\n    }\n    markerObject.marker = marker;\n  });\n\n  // apply marker callbacks and remove marker objects that are stale\n  markerObjects.children.forEach(markerObject => {\n    if (!markerIdSet.has(markerObject.marker.id)) {\n      const from = markerObject.scale.toArray();\n      tween({\n        from,\n        to: [0, 0, 0],\n        animationDuration: markerExitAnimationDuration,\n        easingFunction: markerExitEasingFunction,\n        onUpdate: () => {\n          if (markerObject) {\n            markerObject.scale.set(...from);\n          }\n        },\n        onEnd: () => {\n          markerObjects.remove(markerObject);\n        },\n      });\n    }\n    applyCallbacks(markerObject, callbacks);\n  });\n}\n\nfunction createMarkerObject(marker, options, size) {\n  const {\n    enableMarkerGlow,\n    markerEnterAnimationDuration,\n    markerEnterEasingFunction,\n    markerGlowCoefficient,\n    markerGlowPower,\n    markerGlowRadiusScale,\n    markerOffsetRadiusScale,\n    markerRenderer,\n    markerType,\n  } = options;\n  const unitRadius = RADIUS * MARKER_UNIT_RADIUS_SCALE;\n\n  let markerObject;\n  if (markerRenderer) {\n    markerObject = markerRenderer(marker);\n  } else {\n    const color = marker.color || MARKER_DEFAULT_COLOR;\n    const from = { size: 0 };\n    const to = { size };\n    const mesh = new Mesh();\n    tween({\n      from,\n      to,\n      animationDuration: markerEnterAnimationDuration,\n      easingFunction: markerEnterEasingFunction,\n      onUpdate: () => {\n        switch (markerType) {\n          case MarkerTypes.BAR:\n            mesh.geometry = new BoxGeometry(unitRadius, unitRadius, from.size);\n            mesh.material = new MeshLambertMaterial({ color });\n            break;\n          case MarkerTypes.DOT:\n          default:\n            mesh.geometry = new SphereGeometry(\n              from.size,\n              MARKER_SEGMENTS,\n              MARKER_SEGMENTS,\n            );\n            mesh.material = new MeshBasicMaterial({ color });\n            if (enableMarkerGlow) {\n              const glow = createGlowMesh(mesh.geometry, {\n                backside: false,\n                coefficient: markerGlowCoefficient,\n                color,\n                power: markerGlowPower,\n                size: from.size * markerGlowRadiusScale,\n              });\n              mesh.children = [];\n              mesh.add(glow);\n            }\n        }\n      },\n    });\n    markerObject = mesh;\n  }\n\n  // place markers\n  let heightOffset = 0;\n  if (markerOffsetRadiusScale) {\n    heightOffset = RADIUS * markerOffsetRadiusScale;\n  } else if (markerType === MarkerTypes.DOT) {\n    heightOffset = (size * (1 + markerGlowRadiusScale)) / 2;\n  } else {\n    heightOffset = 0;\n  }\n  const position = coordinatesToPosition(\n    marker.coordinates,\n    RADIUS + heightOffset,\n  );\n  markerObject.position.set(...position);\n  markerObject.lookAt(new Vector3(0, 0, 0));\n\n  markerObject.name = marker.id;\n\n  return markerObject;\n}\n\nfunction applyCallbacks(markerObject, callbacks) {\n  const { marker } = markerObject;\n\n  // TODO: remove hack and find formal way to remove listener\n  markerObject._listeners = {};\n  markerObject.on('click', interaction => {\n    const event = interaction.data.originalEvent;\n    callbacks.onClickMarker(marker, markerObject, event);\n  });\n  markerObject.on('mousemove', interaction => {\n    const event = interaction.data.originalEvent;\n    callbacks.onMouseOverMarker(marker, markerObject, event);\n  });\n  markerObject.on('mouseout', interaction => {\n    const event = interaction.data.originalEvent;\n    callbacks.onMouseOutMarker(marker, markerObject, event);\n  });\n}\n","import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n\nimport { RADIUS } from './enums';\n\nconst ORBIT_CONTROLS_DAMPING_FACTOR = 0.1;\nconst ORBIT_CONTROLS_MIN_DISTANCE_RADIUS_SCALE = 1.1;\n\nexport function createOrbitControls(camera, renderer) {\n  return new OrbitControls(camera, renderer.domElement);\n}\n\nexport function updateOrbitControls(orbitControls, options) {\n  const {\n    cameraAutoRotateSpeed,\n    cameraMaxDistanceRadiusScale,\n    cameraMaxPolarAngle,\n    cameraMinPolarAngle,\n    cameraRotateSpeed,\n    cameraZoomSpeed,\n    enableCameraAutoRotate,\n    enableCameraRotate,\n    enableCameraZoom,\n  } = options;\n\n  orbitControls.autoRotate = enableCameraAutoRotate;\n  orbitControls.autoRotateSpeed = cameraAutoRotateSpeed;\n  orbitControls.dampingFactor = ORBIT_CONTROLS_DAMPING_FACTOR;\n  orbitControls.enableDamping = true;\n  orbitControls.enablePan = false;\n  orbitControls.enableRotate = enableCameraRotate;\n  orbitControls.enableZoom = enableCameraZoom;\n  orbitControls.maxDistance = RADIUS * cameraMaxDistanceRadiusScale;\n  orbitControls.maxPolarAngle = cameraMaxPolarAngle;\n  orbitControls.minDistance = RADIUS * ORBIT_CONTROLS_MIN_DISTANCE_RADIUS_SCALE;\n  orbitControls.minPolarAngle = cameraMinPolarAngle;\n  orbitControls.rotateSpeed = cameraRotateSpeed;\n  orbitControls.zoomSpeed = cameraZoomSpeed;\n}\n","import { Scene } from 'three';\nimport { Interaction } from 'three.interaction';\n\nexport function createScene({\n  camera,\n  earth,\n  lights,\n  markerObjects,\n  renderer,\n  defocus,\n}) {\n  const scene = new Scene();\n\n  camera.add(lights.ambient);\n  camera.add(lights.point);\n  scene.add(camera);\n  scene.add(earth.globe);\n  scene.add(markerObjects);\n\n  new Interaction(renderer, scene, camera);\n\n  // @ts-ignore\n  scene.on('click', defocus);\n\n  return scene;\n}\n","import { RADIUS } from './enums';\nimport { coordinatesToPosition, tween } from './utils';\n\nexport function updateFocus(\n  focus,\n  camera,\n  { options, previousFocus, shouldUnlockAfterFocus, lock, unlock, saveFocus },\n) {\n  const {\n    cameraDistanceRadiusScale,\n    focusAnimationDuration,\n    focusDistanceRadiusScale,\n    focusEasingFunction,\n  } = options;\n\n  if (focus) {\n    const from = [camera.position.x, camera.position.y, camera.position.z];\n    const to = coordinatesToPosition(focus, RADIUS * focusDistanceRadiusScale);\n    saveFocus(focus);\n\n    lock();\n    tween({\n      from,\n      to,\n      animationDuration: focusAnimationDuration,\n      easingFunction: focusEasingFunction,\n      onUpdate: () => {\n        const [x, y, z] = from;\n        camera.position.set(x, y, z);\n      },\n      onEnd: () => {\n        if (shouldUnlockAfterFocus) {\n          unlock();\n        }\n      },\n    });\n  } else if (previousFocus) {\n    const from = [camera.position.x, camera.position.y, camera.position.z];\n    const to = coordinatesToPosition(\n      previousFocus,\n      RADIUS * cameraDistanceRadiusScale,\n    );\n\n    lock();\n    tween({\n      from,\n      to,\n      animationDuration: focusAnimationDuration,\n      easingFunction: focusEasingFunction,\n      onUpdate: () => {\n        const [x, y, z] = from;\n        camera.position.set(x, y, z);\n      },\n      onEnd: () => {\n        saveFocus(null);\n        unlock();\n      },\n    });\n  }\n}\n","import React, { useEffect, useRef } from 'react';\n\nimport { defaultOptions } from './defaults';\nimport Globe from './globe';\nimport { resize } from './utils';\n\nexport default function ReactGlobe({\n  animations = [],\n  focus,\n  height = '100%',\n  globeBackgroundTexture,\n  globeCloudsTexture,\n  globeTexture,\n  initialCameraDistanceRadiusScale,\n  initialCoordinates,\n  markers,\n  options = defaultOptions,\n  width = '100%',\n  onClickMarker,\n  onDefocus,\n  onGetGlobe,\n  onGlobeBackgroundTextureLoaded,\n  onGlobeCloudsTextureLoaded,\n  onGlobeTextureLoaded,\n  onMouseOutMarker,\n  onMouseOverMarker,\n}) {\n  const canvasRef = useRef(null);\n  const mountRef = useRef(null);\n  const tooltipRef = useRef(null);\n  const globeRef = useRef(null);\n\n  useEffect(() => {\n    const canvasElement = canvasRef.current;\n    const tooltipElement = tooltipRef.current;\n    const globe = new Globe({\n      canvasElement,\n      initialCameraDistanceRadiusScale:\n        initialCameraDistanceRadiusScale || options.cameraDistanceRadiusScale,\n      initialCoordinates,\n      textures: {\n        globeBackgroundTexture,\n        globeCloudsTexture,\n        globeTexture,\n      },\n      tooltipElement,\n    });\n    globe.animate();\n    globeRef.current = globe;\n    if (onGetGlobe) {\n      onGetGlobe(globe);\n    }\n    return () => globe.destroy();\n  }, [\n    globeBackgroundTexture,\n    globeCloudsTexture,\n    globeTexture,\n    initialCameraDistanceRadiusScale,\n    options.cameraDistanceRadiusScale,\n    initialCoordinates,\n    onGetGlobe,\n  ]);\n\n  // resize\n  useEffect(() => {\n    const mount = mountRef.current;\n    const globe = globeRef.current;\n    return resize(mount, globe.resize.bind(globe));\n  }, []);\n\n  // update callbacks\n  useEffect(() => {\n    const globe = globeRef.current;\n    globe.updateCallbacks({\n      onClickMarker,\n      onDefocus,\n      onGlobeBackgroundTextureLoaded,\n      onGlobeCloudsTextureLoaded,\n      onGlobeTextureLoaded,\n      onMouseOutMarker,\n      onMouseOverMarker,\n    });\n  }, [\n    onClickMarker,\n    onDefocus,\n    onGlobeBackgroundTextureLoaded,\n    onGlobeCloudsTextureLoaded,\n    onGlobeTextureLoaded,\n    onMouseOutMarker,\n    onMouseOverMarker,\n  ]);\n\n  // update options\n  useEffect(() => {\n    const globe = globeRef.current;\n    globe.updateOptions(options);\n  }, [options]);\n\n  // update markers\n  useEffect(() => {\n    const globe = globeRef.current;\n    globe.updateMarkers(markers);\n  }, [markers]);\n\n  // update focus\n  useEffect(() => {\n    const globe = globeRef.current;\n    globe.updateFocus(focus);\n  }, [focus]);\n\n  // apply animations\n  useEffect(() => {\n    const globe = globeRef.current;\n    return globe.applyAnimations(animations);\n  }, [animations]);\n\n  return (\n    <div ref={mountRef} style={{ height, width }}>\n      <canvas ref={canvasRef} />\n      <div ref={tooltipRef} />\n    </div>\n  );\n}\n"],"names":["defaultCallbacks","onClickMarker","_marker","_markerObject","_event","onDefocus","_previousFocus","onGlobeBackgroundTextureLoaded","onGlobeCloudsTextureLoaded","onGlobeTextureLoaded","onMouseOutMarker","onMouseOverMarker","defaultGlobeBackgroundTexture","defaultGlobeCloudsTexture","defaultGlobeTexture","defaultInitialCoordinates","defaultOptions","ambientLightColor","ambientLightIntensity","cameraAutoRotateSpeed","cameraDistanceRadiusScale","cameraMaxDistanceRadiusScale","CAMERA_FAR_RADIUS_SCALE","cameraMaxPolarAngle","Math","PI","cameraMinPolarAngle","cameraRotateSpeed","cameraZoomSpeed","enableCameraAutoRotate","enableCameraRotate","enableCameraZoom","enableDefocus","enableGlobeGlow","enableMarkerGlow","enableMarkerTooltip","focusAnimationDuration","focusDistanceRadiusScale","focusEasingFunction","globeCloudsOpacity","globeGlowCoefficient","globeGlowColor","globeGlowPower","globeGlowRadiusScale","markerEnterAnimationDuration","markerEnterEasingFunction","markerExitAnimationDuration","markerExitEasingFunction","markerGlowCoefficient","markerGlowPower","markerGlowRadiusScale","markerOffsetRadiusScale","markerRadiusScaleRange","markerRenderer","markerTooltipRenderer","marker","JSON","stringify","coordinates","markerType","pointLightColor","pointLightIntensity","pointLightPositionRadiusScales","defaultDotMarkerOptions","defaultBarMarkerOptions","coordinatesToPosition","radius","lat","long","phi","theta","cos","sin","merge","object","defaultObject","merged","Object","keys","forEach","key","value","undefined","tween","from","to","animationDuration","easingFunction","onUpdate","onEnd","delay","equation","type","TWEEN","easing","on","start","Tooltip","constructor","element","this","instance","tippy","animation","arrow","destroy","hide","document","body","style","cursor","position","left","top","show","clientX","clientY","content","setContent","Globe","canvasElement","initialCameraDistanceRadiusScale","initialCoordinates","textures","tooltipElement","callbacks","focus","isLocked","markers","options","previousFocus","tooltip","renderer","WebGLRenderer","alpha","antialias","canvas","camera","PerspectiveCamera","name","far","RADIUS","fov","near","x","y","z","set","createCamera","earth","globe","Mesh","geometry","SphereGeometry","clouds","background","createEarth","lights","ambient","AmbientLight","point","PointLight","createLights","markerObjects","Group","createMarkerObjects","orbitControls","OrbitControls","domElement","scene","defocus","Scene","add","Interaction","createScene","bind","updateOptions","updateCallbacks","updateMarkers","animate","render","animationFrameId","requestAnimationFrame","animateClouds","axis","rotation","random","applyAnimations","animations","wait","timeouts","i","overrideOptions","shouldUnlockAfterFocus","length","timeout","setTimeout","unlock","updateFocus","push","clearTimeout","cancelAnimationFrame","remove","lock","enabled","autoRotate","sortObjects","update","resize","size","height","width","setSize","aspect","updateProjectionMatrix","saveFocus","focusPosition","markerValues","map","markerIdSet","Set","id","radiusScaleMin","radiusScaleMax","sizeScale","scaleLinear","domain","min","apply","max","range","markerObject","children","find","color","mesh","BoxGeometry","material","MeshLambertMaterial","MeshBasicMaterial","glow","createGlowMesh","backside","coefficient","power","heightOffset","lookAt","Vector3","createMarkerObject","has","scale","toArray","_listeners","interaction","data","originalEvent","applyCallbacks","updateMarkerObjects","event","globeBackgroundTexture","globeCloudsTexture","globeTexture","TextureLoader","load","getObjectByName","side","BackSide","transparent","opacity","updateEarth","scaleX","scaleY","scaleZ","Color","intensity","updateLights","autoRotateSpeed","dampingFactor","enableDamping","enablePan","enableRotate","enableZoom","maxDistance","maxPolarAngle","minDistance","minPolarAngle","rotateSpeed","zoomSpeed","updateOrbitControls","onGetGlobe","canvasRef","useRef","mountRef","tooltipRef","globeRef","useEffect","current","callback","resizeObserver","ResizeObserver","entries","contentRect","observe","unobserve","React","ref"],"mappings":"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"}