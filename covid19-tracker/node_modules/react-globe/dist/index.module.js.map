{"version":3,"file":"index.module.js","sources":["../lib/defaults.js","../lib/enums.js","../lib/utils.js","../lib/tooltip.js","../lib/globe.js","../lib/lights.js","../lib/markers.js","../lib/renderer.js","../lib/camera.js","../lib/earth.js","../lib/orbit-controls.js","../lib/scene.js","../lib/focus.js","../lib/component.js"],"sourcesContent":["import { BACKGROUND_RADIUS_SCALE, MarkerTypes } from './enums';\n\nexport const defaultCallbacks = {\n  onClickMarker: (_marker, _markerObject, _event) => {},\n  onDefocus: _previousFocus => {},\n  onGlobeBackgroundTextureLoaded: () => {},\n  onGlobeCloudsTextureLoaded: () => {},\n  onGlobeTextureLoaded: () => {},\n  onMouseOutMarker: (_marker, _markerObject, _event) => {},\n  onMouseOverMarker: (_marker, _markerObject, _event) => {},\n};\n\nexport const defaultGlobeBackgroundTexture =\n  'https://raw.githubusercontent.com/chrisrzhou/react-globe/main/textures/background.png';\n\nexport const defaultGlobeCloudsTexture =\n  'https://raw.githubusercontent.com/chrisrzhou/react-globe/main/textures/clouds.png';\n\nexport const defaultGlobeTexture =\n  'https://raw.githubusercontent.com/chrisrzhou/react-globe/main/textures/globe.jpg';\n\nexport const defaultInitialCoordinates = [1.29027, 103.851959]; // singapore!\n\nexport const defaultOptions = {\n  ambientLightColor: 'white',\n  ambientLightIntensity: 0.8,\n  cameraAutoRotateSpeed: 0.1,\n  cameraDistanceRadiusScale: 3,\n  cameraMaxDistanceRadiusScale: BACKGROUND_RADIUS_SCALE,\n  cameraMaxPolarAngle: Math.PI,\n  cameraMinPolarAngle: 0,\n  cameraRotateSpeed: 0.2,\n  cameraZoomSpeed: 1,\n  enableCameraAutoRotate: true,\n  enableCameraRotate: true,\n  enableCameraZoom: true,\n  enableDefocus: true,\n  enableGlobeGlow: true,\n  enableMarkerGlow: true,\n  enableMarkerTooltip: true,\n  focusAnimationDuration: 1000,\n  focusDistanceRadiusScale: 1.5,\n  focusEasingFunction: ['Cubic', 'Out'],\n  globeCloudsOpacity: 0.3,\n  globeGlowCoefficient: 0.1,\n  globeGlowColor: '#d1d1d1',\n  globeGlowPower: 3,\n  globeGlowRadiusScale: 0.2,\n  markerEnterAnimationDuration: 1000,\n  markerEnterEasingFunction: ['Linear', 'None'],\n  markerExitAnimationDuration: 500,\n  markerExitEasingFunction: ['Cubic', 'Out'],\n  markerGlowCoefficient: 0,\n  markerGlowPower: 3,\n  markerGlowRadiusScale: 2,\n  markerOffsetRadiusScale: 0,\n  markerRadiusScaleRange: [0.005, 0.02],\n  markerRenderer: null,\n  markerTooltipRenderer: marker => JSON.stringify(marker.coordinates),\n  markerType: MarkerTypes.DOT,\n  pointLightColor: 'white',\n  pointLightIntensity: 1,\n  pointLightPositionRadiusScales: [-2, 1, -1],\n};\n\nexport const defaultDotMarkerOptions = {\n  enableMarkerGlow: true,\n  markerRadiusScaleRange: [0.005, 0.02],\n  markerType: 'dot',\n};\n\nexport const defaultBarMarkerOptions = {\n  enableMarkerGlow: false,\n  markerRadiusScaleRange: [0.2, 0.5],\n  markerType: 'bar',\n};\n","export const CAMERA_FAR_RADIUS_SCALE = 1000;\nexport const BACKGROUND_RADIUS_SCALE = CAMERA_FAR_RADIUS_SCALE / 10;\nexport const RADIUS = 300;\n\nexport const MarkerTypes = {\n  BAR: 'bar',\n  DOT: 'dot',\n};\n","import * as TWEEN from 'es6-tween';\nimport ResizeObserver from 'resize-observer-polyfill';\n\nexport function coordinatesToPosition(coordinates, radius) {\n  const [lat, long] = coordinates;\n  const phi = (lat * Math.PI) / 180;\n  const theta = ((long - 180) * Math.PI) / 180;\n\n  const x = -radius * Math.cos(phi) * Math.cos(theta);\n  const y = radius * Math.sin(phi);\n  const z = radius * Math.cos(phi) * Math.sin(theta);\n\n  return [x, y, z];\n}\n\nexport function merge(object, defaultObject) {\n  const merged = { ...defaultObject };\n  Object.keys(merged).forEach(key => {\n    const value = object[key];\n    merged[key] = value === undefined ? merged[key] : value;\n  });\n  return merged;\n}\n\nexport function resize(element, callback) {\n  const resizeObserver = new ResizeObserver(entries => {\n    if (!entries || entries.length === 0) {\n      return;\n    }\n    const { height, width } = entries[0].contentRect;\n    callback({ height, width });\n  });\n\n  resizeObserver.observe(element);\n\n  return () => resizeObserver.unobserve(element);\n}\n\nexport function tween({\n  from,\n  to,\n  animationDuration,\n  easingFunction,\n  onUpdate,\n  onEnd = null,\n  delay = 0,\n}) {\n  const [equation, type] = easingFunction;\n\n  new TWEEN.Tween(from)\n    .to(to, animationDuration)\n    .easing(TWEEN.Easing[equation][type])\n    .on('update', onUpdate)\n    .on('complete', onEnd)\n    .delay(delay)\n    .start();\n}\n","import tippy from 'tippy.js';\n\nconst TOOLTIP_OFFSET = 10;\n\nexport default class Tooltip {\n  constructor(element) {\n    this.element = element;\n    this.instance = tippy([element], {\n      animation: 'scale',\n      arrow: false,\n    })[0];\n  }\n\n  destroy() {\n    this.instance.destroy();\n  }\n\n  hide() {\n    document.body.style.cursor = 'inherit';\n    this.element.style.position = 'fixed';\n    this.element.style.left = '0';\n    this.element.style.top = '0';\n    this.instance.hide();\n  }\n\n  show(clientX, clientY, content) {\n    document.body.style.cursor = 'pointer';\n    this.element.style.position = 'fixed';\n    this.element.style.left = `${clientX + TOOLTIP_OFFSET}px`;\n    this.element.style.top = `${clientY + TOOLTIP_OFFSET}px`;\n    this.instance.setContent(content);\n    this.instance.show();\n  }\n}\n","import * as TWEEN from 'es6-tween';\n\nimport { createCamera } from './camera';\nimport {\n  defaultCallbacks,\n  defaultInitialCoordinates,\n  defaultOptions,\n} from './defaults';\nimport { createEarth, updateEarth } from './earth';\nimport { updateFocus } from './focus';\nimport { createLights, updateLights } from './lights';\nimport { createMarkerObjects, updateMarkerObjects } from './markers';\nimport { createOrbitControls, updateOrbitControls } from './orbit-controls';\nimport { createRenderer } from './renderer';\nimport { createScene } from './scene';\nimport Tooltip from './tooltip';\nimport { merge } from './utils';\n\nexport default class Globe {\n  constructor({\n    canvasElement,\n    initialCameraDistanceRadiusScale = defaultOptions.cameraDistanceRadiusScale,\n    initialCoordinates = defaultInitialCoordinates,\n    textures = {},\n    tooltipElement,\n  }) {\n    // state variables\n    this.callbacks = defaultCallbacks;\n    this.focus = null;\n    this.isLocked = false;\n    this.markers = [];\n    this.options = defaultOptions;\n    this.textures = textures;\n    this.previousFocus = null;\n    this.tooltip = new Tooltip(tooltipElement);\n\n    // create objects\n    this.renderer = createRenderer(canvasElement);\n    this.camera = createCamera(\n      initialCoordinates,\n      initialCameraDistanceRadiusScale,\n    );\n    this.earth = createEarth();\n    this.lights = createLights();\n    this.markerObjects = createMarkerObjects();\n    this.orbitControls = createOrbitControls(this.camera, this.renderer);\n\n    // assemble scene\n    this.scene = createScene({\n      camera: this.camera,\n      earth: this.earth,\n      lights: this.lights,\n      markerObjects: this.markerObjects,\n      renderer: this.renderer,\n      defocus: this.defocus.bind(this),\n    });\n\n    // initialize\n    this.updateOptions();\n    this.updateCallbacks();\n    this.updateMarkers();\n  }\n\n  animate() {\n    this.render();\n    this.animationFrameId = requestAnimationFrame(this.animate.bind(this));\n  }\n\n  // TODO: make this configurable\n  animateClouds() {\n    ['x', 'y', 'z'].forEach(axis => {\n      this.earth.clouds.rotation[axis] += Math.random() / 10000;\n    });\n  }\n\n  applyAnimations(animations) {\n    // const currentFocus = this.focus;\n    // const currentFocusOptions = this.options.focus;\n    let wait = 0;\n    const timeouts = [];\n    animations.forEach((animation, i) => {\n      const {\n        coordinates,\n        focusAnimationDuration,\n        focusDistanceRadiusScale,\n        focusEasingFunction,\n      } = animation;\n      const overrideOptions = {\n        focusAnimationDuration,\n        focusDistanceRadiusScale,\n        focusEasingFunction,\n      };\n      const shouldUnlockAfterFocus = i === animations.length - 1;\n\n      const timeout = setTimeout(() => {\n        this.unlock();\n        this.updateFocus(coordinates, overrideOptions, shouldUnlockAfterFocus);\n      }, wait);\n      timeouts.push(timeout);\n      wait += focusAnimationDuration;\n    });\n\n    return () => {\n      timeouts.forEach(timeout => {\n        clearTimeout(timeout);\n      });\n    };\n  }\n\n  defocus() {\n    if (!this.isLocked && this.previousFocus && this.options.enableDefocus) {\n      this.updateFocus(null);\n      this.callbacks.onDefocus(this.previousFocus);\n    }\n  }\n\n  destroy() {\n    cancelAnimationFrame(this.animationFrameId);\n    this.tooltip.destroy();\n    this.renderer.domElement.remove();\n  }\n\n  lock() {\n    this.isLocked = true;\n    this.orbitControls.enabled = false;\n    this.orbitControls.autoRotate = false;\n  }\n\n  render() {\n    this.renderer.sortObjects = false;\n    this.renderer.render(this.scene, this.camera);\n    this.orbitControls.update();\n    this.animateClouds();\n    TWEEN.update();\n  }\n\n  resize(size) {\n    const { height, width } = size;\n    this.renderer.setSize(width, height);\n    this.camera.aspect = width / height;\n    this.camera.updateProjectionMatrix();\n    this.render();\n  }\n\n  saveFocus(focusPosition) {\n    this.previousFocus = focusPosition;\n  }\n\n  unlock() {\n    this.isLocked = false;\n    this.orbitControls.enabled = true;\n    this.orbitControls.autoRotate = true;\n  }\n\n  updateCallbacks(callbacks = {}) {\n    this.callbacks = merge(callbacks, defaultCallbacks);\n  }\n\n  updateFocus(focus, overrideOptions = {}, shouldUnlockAfterFocus = true) {\n    if (!this.isLocked) {\n      this.focus = focus;\n      updateFocus(this.focus, this.camera, {\n        shouldUnlockAfterFocus,\n        options: merge(overrideOptions, this.options),\n        previousFocus: this.previousFocus,\n        lock: this.lock.bind(this),\n        unlock: this.unlock.bind(this),\n        saveFocus: this.saveFocus.bind(this),\n      });\n    }\n  }\n\n  updateMarkers(markers = []) {\n    this.markers = markers;\n    const callbacks = {\n      onClickMarker: (marker, markerObject, event) => {\n        this.updateFocus(marker.coordinates);\n        this.callbacks.onClickMarker(marker, markerObject, event);\n      },\n      onMouseOutMarker: (marker, markerObject, event) => {\n        this.tooltip.hide();\n        this.callbacks.onMouseOutMarker(marker, markerObject, event);\n      },\n      onMouseOverMarker: (marker, markerObject, event) => {\n        if (this.options.enableMarkerTooltip) {\n          this.tooltip.show(\n            event.clientX,\n            event.clientY,\n            this.options.markerTooltipRenderer(markerObject.marker),\n          );\n        }\n        this.callbacks.onMouseOverMarker(marker, markerObject, event);\n      },\n    };\n    updateMarkerObjects(this.markerObjects, {\n      options: this.options,\n      markers,\n      callbacks,\n    });\n  }\n\n  updateOptions(options = {}) {\n    this.options = merge(options, defaultOptions);\n    updateEarth(this.earth, {\n      callbacks: this.callbacks,\n      options: this.options,\n      textures: this.textures,\n    });\n    updateLights(this.lights, this.options);\n    updateOrbitControls(this.orbitControls, this.options);\n    this.updateFocus.bind(this, this.focus);\n    this.updateMarkers.bind(this, this.markers);\n  }\n}\n","import { AmbientLight, Color, PointLight } from 'three';\n\nimport { RADIUS } from './enums';\n\nexport function createLights() {\n  const ambient = new AmbientLight('white');\n  const point = new PointLight('white');\n\n  ambient.name = 'ambientLight';\n  point.name = 'pointLight';\n\n  return {\n    ambient,\n    point,\n  };\n}\n\nexport function updateLights(lights, options) {\n  const {\n    ambientLightColor,\n    ambientLightIntensity,\n    pointLightColor,\n    pointLightIntensity,\n    pointLightPositionRadiusScales,\n  } = options;\n  const { ambient, point } = lights;\n  const [scaleX, scaleY, scaleZ] = pointLightPositionRadiusScales;\n\n  ambient.color = new Color(ambientLightColor);\n  ambient.intensity = ambientLightIntensity;\n\n  point.color = new Color(pointLightColor);\n  point.intensity = pointLightIntensity;\n  point.position.set(RADIUS * scaleX, RADIUS * scaleY, RADIUS * scaleZ);\n}\n","import { scaleLinear } from 'd3-scale';\nimport {\n  BoxGeometry,\n  Group,\n  Mesh,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  SphereGeometry,\n  Vector3,\n} from 'three';\nimport { createGlowMesh } from 'three-glow-mesh';\n\nimport { RADIUS, MarkerTypes } from './enums';\nimport { coordinatesToPosition, tween } from './utils';\n\nconst MARKER_DEFAULT_COLOR = 'gold';\nconst MARKER_SEGMENTS = 10;\nconst MARKER_UNIT_RADIUS_SCALE = 0.01;\n\nexport function createMarkerObjects() {\n  const markerObjects = new Group();\n  markerObjects.name = 'markers';\n\n  return markerObjects;\n}\n\nexport function updateMarkerObjects(\n  markerObjects,\n  { callbacks, markers, options },\n) {\n  const {\n    markerExitAnimationDuration,\n    markerExitEasingFunction,\n    markerRadiusScaleRange,\n  } = options;\n\n  const markerValues = markers.map(marker => marker.value);\n  const markerIdSet = new Set(markers.map(marker => marker.id));\n  const [radiusScaleMin, radiusScaleMax] = markerRadiusScaleRange;\n\n  const sizeScale = scaleLinear()\n    .domain([\n      Math.min.apply(null, markerValues),\n      Math.max.apply(null, markerValues),\n    ])\n    .range([RADIUS * radiusScaleMin, RADIUS * radiusScaleMax]);\n\n  markers.forEach(marker => {\n    const { id, value } = marker;\n    const size = sizeScale(value);\n\n    // create new marker objects if non-existent\n    let markerObject = markerObjects.children.find(\n      object => object.marker.id === marker.id,\n    );\n    if (!markerObject) {\n      markerObject = createMarkerObject(marker, options, size);\n      markerObject.name = id;\n      markerObjects.add(markerObject);\n    }\n    markerObject.marker = marker;\n  });\n\n  // apply marker callbacks and remove marker objects that are stale\n  markerObjects.children.forEach(markerObject => {\n    if (!markerIdSet.has(markerObject.marker.id)) {\n      const from = markerObject.scale.toArray();\n      tween({\n        from,\n        to: [0, 0, 0],\n        animationDuration: markerExitAnimationDuration,\n        easingFunction: markerExitEasingFunction,\n        onUpdate: () => {\n          if (markerObject) {\n            markerObject.scale.set(...from);\n          }\n        },\n        onEnd: () => {\n          markerObjects.remove(markerObject);\n        },\n      });\n    }\n    applyCallbacks(markerObject, callbacks);\n  });\n}\n\nfunction createMarkerObject(marker, options, size) {\n  const {\n    enableMarkerGlow,\n    markerEnterAnimationDuration,\n    markerEnterEasingFunction,\n    markerGlowCoefficient,\n    markerGlowPower,\n    markerGlowRadiusScale,\n    markerOffsetRadiusScale,\n    markerRenderer,\n    markerType,\n  } = options;\n  const unitRadius = RADIUS * MARKER_UNIT_RADIUS_SCALE;\n\n  let markerObject;\n  if (markerRenderer) {\n    markerObject = markerRenderer(marker);\n  } else {\n    const color = marker.color || MARKER_DEFAULT_COLOR;\n    const from = { size: 0 };\n    const to = { size };\n    const mesh = new Mesh();\n    tween({\n      from,\n      to,\n      animationDuration: markerEnterAnimationDuration,\n      easingFunction: markerEnterEasingFunction,\n      onUpdate: () => {\n        switch (markerType) {\n          case MarkerTypes.BAR:\n            mesh.geometry = new BoxGeometry(unitRadius, unitRadius, from.size);\n            mesh.material = new MeshLambertMaterial({ color });\n            break;\n          case MarkerTypes.DOT:\n          default:\n            mesh.geometry = new SphereGeometry(\n              from.size,\n              MARKER_SEGMENTS,\n              MARKER_SEGMENTS,\n            );\n            mesh.material = new MeshBasicMaterial({ color });\n            if (enableMarkerGlow) {\n              const glow = createGlowMesh(mesh.geometry, {\n                backside: false,\n                coefficient: markerGlowCoefficient,\n                color,\n                power: markerGlowPower,\n                size: from.size * markerGlowRadiusScale,\n              });\n              mesh.children = [];\n              mesh.add(glow);\n            }\n        }\n      },\n    });\n    markerObject = mesh;\n  }\n\n  // place markers\n  let heightOffset = 0;\n  if (markerOffsetRadiusScale) {\n    heightOffset = RADIUS * markerOffsetRadiusScale;\n  } else if (markerType === MarkerTypes.DOT) {\n    heightOffset = (size * (1 + markerGlowRadiusScale)) / 2;\n  } else {\n    heightOffset = 0;\n  }\n  const position = coordinatesToPosition(\n    marker.coordinates,\n    RADIUS + heightOffset,\n  );\n  markerObject.position.set(...position);\n  markerObject.lookAt(new Vector3(0, 0, 0));\n\n  markerObject.name = marker.id;\n\n  return markerObject;\n}\n\nfunction applyCallbacks(markerObject, callbacks) {\n  const { marker } = markerObject;\n\n  // TODO: remove hack and find formal way to remove listener\n  markerObject._listeners = {};\n  markerObject.on('click', interaction => {\n    const event = interaction.data.originalEvent;\n    callbacks.onClickMarker(marker, markerObject, event);\n  });\n  markerObject.on('mousemove', interaction => {\n    const event = interaction.data.originalEvent;\n    callbacks.onMouseOverMarker(marker, markerObject, event);\n  });\n  markerObject.on('mouseout', interaction => {\n    const event = interaction.data.originalEvent;\n    callbacks.onMouseOutMarker(marker, markerObject, event);\n  });\n}\n","import { WebGLRenderer } from 'three';\n\nexport function createRenderer(canvas) {\n  return new WebGLRenderer({\n    alpha: true,\n    antialias: true,\n    canvas,\n  });\n}\n","import { PerspectiveCamera } from 'three';\n\nimport { CAMERA_FAR_RADIUS_SCALE, RADIUS } from './enums';\nimport { coordinatesToPosition } from './utils';\n\nconst CAMERA_FAR = RADIUS * CAMERA_FAR_RADIUS_SCALE;\nconst CAMERA_FOV = 45;\nconst CAMERA_NEAR = 1;\n\nexport function createCamera(\n  initialCoordinates,\n  initialCameraDistanceRadiusScale,\n) {\n  const camera = new PerspectiveCamera();\n\n  camera.name = 'camera';\n  camera.far = CAMERA_FAR;\n  camera.fov = CAMERA_FOV;\n  camera.near = CAMERA_NEAR;\n\n  const [x, y, z] = coordinatesToPosition(\n    initialCoordinates,\n    RADIUS * initialCameraDistanceRadiusScale,\n  );\n  camera.position.set(x, y, z);\n\n  return camera;\n}\n","import {\n  BackSide,\n  Mesh,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  SphereGeometry,\n  TextureLoader,\n} from 'three';\nimport { createGlowMesh } from 'three-glow-mesh';\n\nimport {\n  defaultGlobeBackgroundTexture,\n  defaultGlobeCloudsTexture,\n  defaultGlobeTexture,\n} from './defaults';\nimport { BACKGROUND_RADIUS_SCALE, RADIUS } from './enums';\n\nconst CLOUDS_RADIUS_OFFSET = 1;\nconst GLOBE_SEGMENTS = 50;\n\nexport function createEarth() {\n  const globe = new Mesh();\n  globe.geometry = new SphereGeometry(RADIUS, GLOBE_SEGMENTS, GLOBE_SEGMENTS);\n  globe.name = 'earth';\n\n  const clouds = new Mesh();\n  clouds.geometry = new SphereGeometry(\n    RADIUS + CLOUDS_RADIUS_OFFSET,\n    GLOBE_SEGMENTS,\n    GLOBE_SEGMENTS,\n  );\n  clouds.name = 'clouds';\n\n  const background = new Mesh();\n  background.name = 'background';\n  background.geometry = new SphereGeometry(\n    RADIUS * BACKGROUND_RADIUS_SCALE,\n    GLOBE_SEGMENTS,\n    GLOBE_SEGMENTS,\n  );\n\n  return {\n    clouds,\n    globe,\n    background,\n  };\n}\n\nexport function updateEarth(earth, { callbacks, options, textures }) {\n  const {\n    enableGlobeGlow,\n    globeCloudsOpacity,\n    globeGlowColor,\n    globeGlowCoefficient,\n    globeGlowPower,\n    globeGlowRadiusScale,\n  } = options;\n  const {\n    onGlobeBackgroundTextureLoaded,\n    onGlobeCloudsTextureLoaded,\n    onGlobeTextureLoaded,\n  } = callbacks;\n  const {\n    globeBackgroundTexture = defaultGlobeBackgroundTexture,\n    globeCloudsTexture = defaultGlobeCloudsTexture,\n    globeTexture = defaultGlobeTexture,\n  } = textures;\n  let { clouds, globe, glow, background } = earth;\n\n  if (enableGlobeGlow) {\n    glow = createGlowMesh(globe.geometry, {\n      backside: true,\n      coefficient: globeGlowCoefficient,\n      color: globeGlowColor,\n      power: globeGlowPower,\n      size: RADIUS * globeGlowRadiusScale,\n    });\n    glow.name = 'glow';\n  }\n\n  if (globeTexture) {\n    new TextureLoader().load(\n      globeTexture,\n      map => {\n        globe.material = new MeshLambertMaterial({ map });\n        globe.remove(globe.getObjectByName('glow'));\n        globe.add(glow);\n        onGlobeTextureLoaded();\n      },\n      () => {},\n      onGlobeTextureLoaded,\n    );\n  }\n\n  if (globeBackgroundTexture) {\n    new TextureLoader().load(\n      globeBackgroundTexture,\n      map => {\n        background.material = new MeshBasicMaterial({ map, side: BackSide });\n        onGlobeBackgroundTextureLoaded();\n      },\n      () => {},\n      onGlobeBackgroundTextureLoaded,\n    );\n    globe.remove(globe.getObjectByName('background'));\n    globe.add(background);\n  }\n\n  if (globeCloudsTexture) {\n    new TextureLoader().load(\n      globeCloudsTexture,\n      map => {\n        clouds.material = new MeshLambertMaterial({ map, transparent: true });\n        clouds.material.opacity = globeCloudsOpacity;\n        onGlobeCloudsTextureLoaded();\n      },\n      () => {},\n      onGlobeCloudsTextureLoaded,\n    );\n    globe.remove(globe.getObjectByName('clouds'));\n    globe.add(clouds);\n  }\n}\n","import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n\nimport { RADIUS } from './enums';\n\nconst ORBIT_CONTROLS_DAMPING_FACTOR = 0.1;\nconst ORBIT_CONTROLS_MIN_DISTANCE_RADIUS_SCALE = 1.1;\n\nexport function createOrbitControls(camera, renderer) {\n  return new OrbitControls(camera, renderer.domElement);\n}\n\nexport function updateOrbitControls(orbitControls, options) {\n  const {\n    cameraAutoRotateSpeed,\n    cameraMaxDistanceRadiusScale,\n    cameraMaxPolarAngle,\n    cameraMinPolarAngle,\n    cameraRotateSpeed,\n    cameraZoomSpeed,\n    enableCameraAutoRotate,\n    enableCameraRotate,\n    enableCameraZoom,\n  } = options;\n\n  orbitControls.autoRotate = enableCameraAutoRotate;\n  orbitControls.autoRotateSpeed = cameraAutoRotateSpeed;\n  orbitControls.dampingFactor = ORBIT_CONTROLS_DAMPING_FACTOR;\n  orbitControls.enableDamping = true;\n  orbitControls.enablePan = false;\n  orbitControls.enableRotate = enableCameraRotate;\n  orbitControls.enableZoom = enableCameraZoom;\n  orbitControls.maxDistance = RADIUS * cameraMaxDistanceRadiusScale;\n  orbitControls.maxPolarAngle = cameraMaxPolarAngle;\n  orbitControls.minDistance = RADIUS * ORBIT_CONTROLS_MIN_DISTANCE_RADIUS_SCALE;\n  orbitControls.minPolarAngle = cameraMinPolarAngle;\n  orbitControls.rotateSpeed = cameraRotateSpeed;\n  orbitControls.zoomSpeed = cameraZoomSpeed;\n}\n","import { Scene } from 'three';\nimport { Interaction } from 'three.interaction';\n\nexport function createScene({\n  camera,\n  earth,\n  lights,\n  markerObjects,\n  renderer,\n  defocus,\n}) {\n  const scene = new Scene();\n\n  camera.add(lights.ambient);\n  camera.add(lights.point);\n  scene.add(camera);\n  scene.add(earth.globe);\n  scene.add(markerObjects);\n\n  new Interaction(renderer, scene, camera);\n\n  // @ts-ignore\n  scene.on('click', defocus);\n\n  return scene;\n}\n","import { RADIUS } from './enums';\nimport { coordinatesToPosition, tween } from './utils';\n\nexport function updateFocus(\n  focus,\n  camera,\n  { options, previousFocus, shouldUnlockAfterFocus, lock, unlock, saveFocus },\n) {\n  const {\n    cameraDistanceRadiusScale,\n    focusAnimationDuration,\n    focusDistanceRadiusScale,\n    focusEasingFunction,\n  } = options;\n\n  if (focus) {\n    const from = [camera.position.x, camera.position.y, camera.position.z];\n    const to = coordinatesToPosition(focus, RADIUS * focusDistanceRadiusScale);\n    saveFocus(focus);\n\n    lock();\n    tween({\n      from,\n      to,\n      animationDuration: focusAnimationDuration,\n      easingFunction: focusEasingFunction,\n      onUpdate: () => {\n        const [x, y, z] = from;\n        camera.position.set(x, y, z);\n      },\n      onEnd: () => {\n        if (shouldUnlockAfterFocus) {\n          unlock();\n        }\n      },\n    });\n  } else if (previousFocus) {\n    const from = [camera.position.x, camera.position.y, camera.position.z];\n    const to = coordinatesToPosition(\n      previousFocus,\n      RADIUS * cameraDistanceRadiusScale,\n    );\n\n    lock();\n    tween({\n      from,\n      to,\n      animationDuration: focusAnimationDuration,\n      easingFunction: focusEasingFunction,\n      onUpdate: () => {\n        const [x, y, z] = from;\n        camera.position.set(x, y, z);\n      },\n      onEnd: () => {\n        saveFocus(null);\n        unlock();\n      },\n    });\n  }\n}\n","import React, { useEffect, useRef } from 'react';\n\nimport { defaultOptions } from './defaults';\nimport Globe from './globe';\nimport { resize } from './utils';\n\nexport default function ReactGlobe({\n  animations = [],\n  focus,\n  height = '100%',\n  globeBackgroundTexture,\n  globeCloudsTexture,\n  globeTexture,\n  initialCameraDistanceRadiusScale,\n  initialCoordinates,\n  markers,\n  options = defaultOptions,\n  width = '100%',\n  onClickMarker,\n  onDefocus,\n  onGetGlobe,\n  onGlobeBackgroundTextureLoaded,\n  onGlobeCloudsTextureLoaded,\n  onGlobeTextureLoaded,\n  onMouseOutMarker,\n  onMouseOverMarker,\n}) {\n  const canvasRef = useRef(null);\n  const mountRef = useRef(null);\n  const tooltipRef = useRef(null);\n  const globeRef = useRef(null);\n\n  useEffect(() => {\n    const canvasElement = canvasRef.current;\n    const tooltipElement = tooltipRef.current;\n    const globe = new Globe({\n      canvasElement,\n      initialCameraDistanceRadiusScale:\n        initialCameraDistanceRadiusScale || options.cameraDistanceRadiusScale,\n      initialCoordinates,\n      textures: {\n        globeBackgroundTexture,\n        globeCloudsTexture,\n        globeTexture,\n      },\n      tooltipElement,\n    });\n    globe.animate();\n    globeRef.current = globe;\n    if (onGetGlobe) {\n      onGetGlobe(globe);\n    }\n    return () => globe.destroy();\n  }, [\n    globeBackgroundTexture,\n    globeCloudsTexture,\n    globeTexture,\n    initialCameraDistanceRadiusScale,\n    options.cameraDistanceRadiusScale,\n    initialCoordinates,\n    onGetGlobe,\n  ]);\n\n  // resize\n  useEffect(() => {\n    const mount = mountRef.current;\n    const globe = globeRef.current;\n    return resize(mount, globe.resize.bind(globe));\n  }, []);\n\n  // update callbacks\n  useEffect(() => {\n    const globe = globeRef.current;\n    globe.updateCallbacks({\n      onClickMarker,\n      onDefocus,\n      onGlobeBackgroundTextureLoaded,\n      onGlobeCloudsTextureLoaded,\n      onGlobeTextureLoaded,\n      onMouseOutMarker,\n      onMouseOverMarker,\n    });\n  }, [\n    onClickMarker,\n    onDefocus,\n    onGlobeBackgroundTextureLoaded,\n    onGlobeCloudsTextureLoaded,\n    onGlobeTextureLoaded,\n    onMouseOutMarker,\n    onMouseOverMarker,\n  ]);\n\n  // update options\n  useEffect(() => {\n    const globe = globeRef.current;\n    globe.updateOptions(options);\n  }, [options]);\n\n  // update markers\n  useEffect(() => {\n    const globe = globeRef.current;\n    globe.updateMarkers(markers);\n  }, [markers]);\n\n  // update focus\n  useEffect(() => {\n    const globe = globeRef.current;\n    globe.updateFocus(focus);\n  }, [focus]);\n\n  // apply animations\n  useEffect(() => {\n    const globe = globeRef.current;\n    return globe.applyAnimations(animations);\n  }, [animations]);\n\n  return (\n    <div ref={mountRef} style={{ height, width }}>\n      <canvas ref={canvasRef} />\n      <div ref={tooltipRef} />\n    </div>\n  );\n}\n"],"names":["defaultCallbacks","onClickMarker","_marker","_markerObject","_event","onDefocus","_previousFocus","onGlobeBackgroundTextureLoaded","onGlobeCloudsTextureLoaded","onGlobeTextureLoaded","onMouseOutMarker","onMouseOverMarker","defaultGlobeBackgroundTexture","defaultGlobeCloudsTexture","defaultGlobeTexture","defaultInitialCoordinates","defaultOptions","ambientLightColor","ambientLightIntensity","cameraAutoRotateSpeed","cameraDistanceRadiusScale","cameraMaxDistanceRadiusScale","CAMERA_FAR_RADIUS_SCALE","cameraMaxPolarAngle","Math","PI","cameraMinPolarAngle","cameraRotateSpeed","cameraZoomSpeed","enableCameraAutoRotate","enableCameraRotate","enableCameraZoom","enableDefocus","enableGlobeGlow","enableMarkerGlow","enableMarkerTooltip","focusAnimationDuration","focusDistanceRadiusScale","focusEasingFunction","globeCloudsOpacity","globeGlowCoefficient","globeGlowColor","globeGlowPower","globeGlowRadiusScale","markerEnterAnimationDuration","markerEnterEasingFunction","markerExitAnimationDuration","markerExitEasingFunction","markerGlowCoefficient","markerGlowPower","markerGlowRadiusScale","markerOffsetRadiusScale","markerRadiusScaleRange","markerRenderer","markerTooltipRenderer","marker","JSON","stringify","coordinates","markerType","pointLightColor","pointLightIntensity","pointLightPositionRadiusScales","defaultDotMarkerOptions","defaultBarMarkerOptions","coordinatesToPosition","radius","phi","theta","cos","sin","merge","object","defaultObject","merged","Object","keys","forEach","key","value","undefined","tween","to","animationDuration","easingFunction","onUpdate","onEnd","delay","equation","type","TWEEN","from","easing","on","start","Tooltip","element","this","instance","tippy","animation","arrow","destroy","hide","document","body","style","cursor","position","left","top","show","clientX","clientY","content","setContent","Globe","ambient","point","markerObjects","canvasElement","initialCameraDistanceRadiusScale","initialCoordinates","textures","tooltipElement","callbacks","focus","isLocked","markers","options","previousFocus","tooltip","renderer","WebGLRenderer","alpha","antialias","canvas","camera","PerspectiveCamera","name","far","RADIUS","fov","near","set","createCamera","earth","globe","Mesh","geometry","SphereGeometry","clouds","background","createEarth","lights","AmbientLight","PointLight","Group","orbitControls","OrbitControls","domElement","scene","defocus","Scene","add","Interaction","createScene","bind","updateOptions","updateCallbacks","updateMarkers","animate","render","animationFrameId","requestAnimationFrame","animateClouds","axis","_this","rotation","random","applyAnimations","animations","wait","timeouts","i","overrideOptions","shouldUnlockAfterFocus","length","timeout","setTimeout","_this2","unlock","updateFocus","push","clearTimeout","cancelAnimationFrame","remove","lock","enabled","autoRotate","sortObjects","update","resize","size","height","width","setSize","aspect","updateProjectionMatrix","saveFocus","focusPosition","x","y","z","markerValues","map","markerIdSet","Set","id","radiusScaleMin","radiusScaleMax","sizeScale","scaleLinear","domain","min","apply","max","range","markerObject","children","find","color","mesh","BoxGeometry","material","MeshLambertMaterial","MeshBasicMaterial","glow","createGlowMesh","backside","coefficient","power","lookAt","Vector3","createMarkerObject","has","scale","toArray","_listeners","interaction","data","originalEvent","applyCallbacks","updateMarkerObjects","event","_this3","globeBackgroundTexture","globeCloudsTexture","globeTexture","TextureLoader","load","getObjectByName","side","BackSide","transparent","opacity","updateEarth","scaleX","scaleY","scaleZ","Color","intensity","updateLights","autoRotateSpeed","dampingFactor","enableDamping","enablePan","enableRotate","enableZoom","maxDistance","maxPolarAngle","minDistance","minPolarAngle","rotateSpeed","zoomSpeed","updateOrbitControls","onGetGlobe","canvasRef","useRef","mountRef","tooltipRef","globeRef","useEffect","current","callback","resizeObserver","ResizeObserver","entries","contentRect","observe","unobserve","React","ref"],"mappings":"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"}