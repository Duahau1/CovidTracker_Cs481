import { BufferGeometry, Float32BufferAttribute, Geometry } from 'three';
import Delaunator from 'delaunator';
import earcut from 'earcut';
import turfPointInPolygon from '@turf/boolean-point-in-polygon';
import { geoDistance, geoInterpolate } from 'd3-geo';
import { merge, extent, mean } from 'd3-array';

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists
: {
  BufferGeometry: BufferGeometry,
  Float32BufferAttribute: Float32BufferAttribute,
  Geometry: Geometry
};

var setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';

function ConicPolygonGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {
  THREE.Geometry.call(this);
  this.type = 'ConicPolygonGeometry';
  this.parameters = {
    polygonGeoJson: polygonGeoJson,
    startHeight: startHeight,
    endHeight: endHeight,
    closedBottom: closedBottom,
    closedTop: closedTop,
    includeSides: includeSides,
    curvatureResolution: curvatureResolution
  };
  this.fromBufferGeometry(new ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution));
  this.mergeVertices();
}

ConicPolygonGeometry.prototype = Object.create(THREE.Geometry.prototype);
ConicPolygonGeometry.prototype.constructor = ConicPolygonGeometry;

function ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {
  var _this = this;

  THREE.BufferGeometry.call(this);
  this.type = 'ConicPolygonBufferGeometry';
  this.parameters = {
    polygonGeoJson: polygonGeoJson,
    startHeight: startHeight,
    endHeight: endHeight,
    closedBottom: closedBottom,
    closedTop: closedTop,
    includeSides: includeSides,
    curvatureResolution: curvatureResolution
  }; // defaults

  startHeight = startHeight || 0;
  endHeight = endHeight || 1;
  closedBottom = closedBottom !== undefined ? closedBottom : true;
  closedTop = closedTop !== undefined ? closedTop : true;
  includeSides = includeSides !== undefined ? includeSides : true;
  curvatureResolution = curvatureResolution || 5; // in angular degrees
  // pre-calculate contour and triangulation

  var contourGeoJson = interpolateContourPoints(polygonGeoJson, curvatureResolution);
  var geoTriangles = (closedTop || closedBottom) && triangulateGeoSurface();
  var vertices = [];
  var indices = [];
  var groupCnt = 0; // add groups to apply different materials to torso / caps

  var addGroup = function addGroup(groupData) {
    var prevVertCnt = Math.round(vertices.length / 3);
    var prevIndCnt = indices.length;
    vertices = vertices.concat(groupData.vertices);
    indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {
      return ind + prevVertCnt;
    }));

    _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);
  };

  includeSides && addGroup(generateTorso());
  closedBottom && addGroup(generateCap(startHeight, false));
  closedTop && addGroup(generateCap(endHeight, true)); // build geometry

  this.setIndex(indices);
  this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3)); // auto-calculate normals

  this.computeFaceNormals();
  this.computeVertexNormals(); //

  function generateVertices(polygon, altitude) {
    var coords3d = polygon.map(function (coords) {
      return coords.map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            lng = _ref2[0],
            lat = _ref2[1];

        return polar2Cartesian(lat, lng, altitude);
      });
    }); // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).

    return earcut.flatten(coords3d);
  }

  function generateTorso() {
    var _generateVertices = generateVertices(contourGeoJson, startHeight),
        bottomVerts = _generateVertices.vertices,
        holes = _generateVertices.holes;

    var _generateVertices2 = generateVertices(contourGeoJson, endHeight),
        topVerts = _generateVertices2.vertices;

    var vertices = merge([topVerts, bottomVerts]);
    var numPoints = Math.round(topVerts.length / 3);
    var holesIdx = new Set(holes);
    var lastHoleIdx = 0;
    var indices = [];

    for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {
      var v1Idx = v0Idx + 1; // next point

      if (v1Idx === numPoints) {
        v1Idx = lastHoleIdx; // close final loop
      } else if (holesIdx.has(v1Idx)) {
        var holeIdx = v1Idx;
        v1Idx = lastHoleIdx; // close hole loop

        lastHoleIdx = holeIdx;
      } // Each pair of coords generates two triangles (faces)


      indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);
      indices.push(v1Idx + numPoints, v1Idx, v0Idx);
    }

    return {
      indices: indices,
      vertices: vertices
    };
  }

  function generateCap(radius) {
    var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return {
      // need to reverse-wind the bottom triangles to make them face outwards
      indices: isTop ? geoTriangles.indices : geoTriangles.indices.slice().reverse(),
      vertices: generateVertices([geoTriangles.points], radius).vertices
    };
  }

  function triangulateGeoSurface() {
    var edgePnts = merge(contourGeoJson);
    var innerPoints = getInnerGeoPoints(polygonGeoJson, curvatureResolution);
    var points = [].concat(_toConsumableArray(edgePnts), _toConsumableArray(innerPoints));
    var indices = [];

    if (!innerPoints.length) {
      // earcut triangulation slightly more performant if it's only using the polygon perimeter
      var _earcut$flatten = earcut.flatten(contourGeoJson),
          _vertices = _earcut$flatten.vertices,
          _earcut$flatten$holes = _earcut$flatten.holes,
          holes = _earcut$flatten$holes === void 0 ? [] : _earcut$flatten$holes;

      indices = earcut(_vertices, holes, 2);
    } else {
      (function () {
        var delaunay = Delaunator.from(points);
        var boundariesGeojson = {
          type: 'Polygon',
          coordinates: polygonGeoJson
        };

        var _loop = function _loop(i, len) {
          var _indices;

          var inds = [2, 1, 0].map(function (idx) {
            return delaunay.triangles[i + idx];
          }); // reverse wound to have same orientation as earcut

          var triangle = inds.map(function (indice) {
            return points[indice];
          }); // exclude edge triangles outside polygon perimeter or through holes

          if (inds.some(function (ind) {
            return ind < edgePnts.length;
          })) {
            var triangleCentroid = [0, 1].map(function (coordIdx) {
              return mean(triangle, function (p) {
                return p[coordIdx];
              });
            });
            if (!pointInside(triangleCentroid, boundariesGeojson)) return "continue";
          }

          (_indices = indices).push.apply(_indices, _toConsumableArray(inds));
        };

        for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {
          var _ret = _loop(i);

          if (_ret === "continue") continue;
        }
      })();
    }

    return {
      points: points,
      indices: indices
    };
  }
}

ConicPolygonBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
ConicPolygonBufferGeometry.prototype.constructor = ConicPolygonBufferGeometry; //

function polar2Cartesian(lat, lng) {
  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var phi = (90 - lat) * Math.PI / 180;
  var theta = (90 - lng) * Math.PI / 180;
  return [r * Math.sin(phi) * Math.cos(theta), // x
  r * Math.cos(phi), // y
  r * Math.sin(phi) * Math.sin(theta) // z
  ];
}

function pointInside(pnt, polygonGeoJson) {
  return turfPointInPolygon(pnt, polygonGeoJson);
}

function interpolateContourPoints(polygonGeoJson, maxDistance) {
  // add interpolated points for segments that are further apart than the max distance
  return polygonGeoJson.map(function (coords) {
    var pnts = [];
    var prevPnt;
    coords.forEach(function (pnt) {
      if (prevPnt) {
        var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;

        if (dist > maxDistance) {
          var interpol = geoInterpolate(prevPnt, pnt);
          var tStep = 1 / Math.ceil(dist / maxDistance);
          var t = tStep;

          while (t < 1) {
            pnts.push(interpol(t));
            t += tStep;
          }
        }
      }

      pnts.push(prevPnt = pnt);
    });
    return pnts;
  });
}

function getInnerGeoPoints(polygonGeoJson, maxDistance) {
  var _extent = extent(polygonGeoJson[0], function (p) {
    return p[0];
  }),
      _extent2 = _slicedToArray(_extent, 2),
      minLng = _extent2[0],
      maxLng = _extent2[1];

  var _extent3 = extent(polygonGeoJson[0], function (p) {
    return p[1];
  }),
      _extent4 = _slicedToArray(_extent3, 2),
      minLat = _extent4[0],
      maxLat = _extent4[1]; // polygon smaller than maxDistance -> no inner points


  if (Math.min(maxLng - minLng, maxLat - minLat) < maxDistance) return []; // distribute grid remainder equally on both sides

  var startLng = minLng + (maxLng - minLng) % maxDistance / 2;
  var startLat = minLat + (maxLat - minLat) % maxDistance / 2;
  var pnts = [];
  var boundariesGeojson = {
    type: 'Polygon',
    coordinates: polygonGeoJson
  }; // iterate through grid

  var lng = startLng;
  var lat;

  while (lng < maxLng) {
    lat = startLat;

    while (lat < maxLat) {
      var pnt = [lng, lat];
      pointInside(pnt, boundariesGeojson) && pnts.push(pnt);
      lat += maxDistance;
    }

    lng += maxDistance;
  }

  return pnts;
}

export { ConicPolygonBufferGeometry, ConicPolygonGeometry };
