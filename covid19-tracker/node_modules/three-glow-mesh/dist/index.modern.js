import{ShaderMaterial as e,Color as o,Face3 as r,BackSide as n,Mesh as t}from"three";const i={backside:!0,coefficient:.5,color:"gold",size:2,power:1};function a(r,n,t){return new e({depthWrite:!1,fragmentShader:"\nuniform vec3 color;\nuniform float coefficient;\nuniform float power;\nvarying vec3 vVertexNormal;\nvarying vec3 vVertexWorldPosition;\nvoid main() {\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\n  vec3 viewCameraToVertex\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\n  viewCameraToVertex = normalize(viewCameraToVertex);\n  float intensity\t= pow(\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\n    power\n  );\n  gl_FragColor = vec4(color, intensity);\n}",transparent:!0,uniforms:{coefficient:{value:r},color:{value:new o(n)},power:{value:t}},vertexShader:"\nvarying vec3 vVertexWorldPosition;\nvarying vec3 vVertexNormal;\nvoid main() {\n  vVertexNormal\t= normalize(normalMatrix * normal);\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  gl_Position\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"})}function c(e,o){const n=e.clone(),t=new Array(n.vertices.length);return n.faces.forEach(e=>{e instanceof r?(t[e.a]=e.vertexNormals[0],t[e.b]=e.vertexNormals[1],t[e.c]=e.vertexNormals[2]):console.error("Face needs to be an instance of THREE.Face3.")}),n.vertices.forEach((e,r)=>{const{x:n,y:i,z:a}=t[r];e.x+=n*o,e.y+=i*o,e.z+=a*o}),n}function v(e,o=i){const{backside:r,coefficient:v,color:l,size:s,power:m}=o,x=c(e,s),f=a(v,l,m);return r&&(f.side=n),new t(x,f)}export{c as createGlowGeometry,a as createGlowMaterial,v as createGlowMesh,i as defaultOptions};
//# sourceMappingURL=index.modern.js.map
